<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Notary DApp - Content Rights Registration</title>
    <style>
        /* Стили остаются без изменений */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

         /* Стили для модального окна покупки токенов */
        .buy-tokens-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
        }

        .buy-tokens-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .token-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .token-option {
            padding: 20px;
            border: 2px solid #E2E8F0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .token-option:hover {
            border-color: #8B5CF6;
            transform: translateY(-2px);
        }

        .token-option.selected {
            border-color: #10B981;
            background: #D1FAE5;
        }

        .token-amount {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .token-price {
            color: #059669;
            font-weight: 600;
        }

        .balance-warning {
            background: #FEF3C7;
            border: 2px solid #F59E0B;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .balance-check {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: #F8FAFC;
            border-radius: 8px;
        }

        .balance-status {
            font-weight: bold;
        }

        .balance-sufficient {
            color: #10B981;
        }

        .balance-insufficient {
            color: #EF4444;
        }

        .quick-buy-section {
            background: #EFF6FF;
            border: 2px solid #3B82F6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        /* Стили для языковой панели - Космический блокчейн */
        .language-selector {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><defs><filter id="twinkle"><feGaussianBlur in="SourceGraphic" stdDeviation="1" result="blur"/><feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" result="twinkle"/></filter></defs><g filter="url(%23twinkle)"><g fill="white"><circle cx="100" cy="100" r="1" opacity="0.8"/><circle cx="300" cy="250" r="0.8" opacity="0.6"/><circle cx="500" cy="150" r="1.2" opacity="0.9"/><circle cx="700" cy="300" r="0.7" opacity="0.5"/><circle cx="900" cy="200" r="1.1" opacity="0.7"/><circle cx="1100" cy="350" r="0.9" opacity="0.6"/><circle cx="200" cy="500" r="1.3" opacity="0.8"/><circle cx="400" cy="600" r="0.6" opacity="0.4"/><circle cx="600" cy="550" r="1" opacity="0.9"/><circle cx="800" cy="450" r="0.8" opacity="0.7"/><circle cx="1000" cy="650" r="1.2" opacity="0.8"/></g></g><g stroke="rgba(59, 130, 246, 0.3)" stroke-width="0.3" fill="none"><path d="M100,100 L300,250 L500,150 L700,300 L900,200 L1100,350"/><path d="M200,500 L400,600 L600,550 L800,450 L1000,650"/><path d="M100,100 L200,500 M300,250 L400,600 M500,150 L600,550 M700,300 L800,450 M900,200 L1000,650"/></g></svg>');
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            text-align: center;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        /* Анимированные звёзды */
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--duration) ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.2; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .app-title-large {
            font-size: 4em;
            font-weight: 800;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #60a5fa, #3b82f6, #6366f1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
            position: relative;
            z-index: 2;
        }

        .app-version {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 50px;
            opacity: 0.9;
            color: #60a5fa;
            position: relative;
            z-index: 2;
        }

        .language-buttons {
            display: flex;
            gap: 30px;
            margin-top: 30px;
            position: relative;
            z-index: 2;
        }

        .lang-btn {
            padding: 20px 40px;
            font-size: 1.5em;
            font-weight: 700;
            border: 2px solid #3b82f6;
            border-radius: 15px;
            background: rgba(59, 130, 246, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .lang-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.4), transparent);
            transition: left 0.5s;
        }

        .lang-btn:hover::before {
            left: 100%;
        }

        .lang-btn:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #60a5fa;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            transform: translateY(-5px);
        }

        .lang-btn.active {
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border-color: white;
        }

        .lang-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .lang-btn:disabled:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            box-shadow: none;
            transform: none;
        }

        .lang-btn:disabled:hover::before {
            left: -100%;
        }

        .language-hint {
            margin-top: 30px;
            opacity: 0.8;
            font-size: 1.1em;
            color: #93c5fd;
            position: relative;
            z-index: 2;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #3f1785 0%, #314688 100%);
            min-height: 100vh;
            padding: 0;
            font-weight: 700;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        .sidebar {
            width: 250px;
            background: rgba(30, 41, 59, 0.95);
            color: white;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            box-shadow: 3px 0 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .app-title {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-bottom: 2px solid #F59E0B;
            font-size: 1.4em;
            font-weight: 800;
        }

        .nav-menu {
            flex: 1;
        }

        .nav-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background: rgba(139, 92, 246, 0.3);
            border-left-color: #8B5CF6;
        }

        .owner-only {
            display: none;
        }

        .user-only {
            display: none;
        }

        .client-only {
            display: none;
        }

        .current-network-display {
            background: rgba(245, 158, 11, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 15px;
            border: 1px solid rgba(245, 158, 11, 0.5);
        }

        .current-network-name {
            font-weight: 800;
            font-size: 0.9em;
            margin-bottom: 3px;
        }

        .current-network-status {
            font-size: 0.8em;
            opacity: 0.9;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
    position: relative;
    z-index: 100;
    background: linear-gradient(135deg, #6D28D9 0%, #075985 100%);
    color: white;
    padding: 15px 25px;
    text-align: center;
    border-bottom: 3px solid #F59E0B;
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 70px; /* Гарантируем достаточную высоту */
}


        .header h1 {
            font-size: 1.8em;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .contract-status {
    background: #EF4444;
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 0.9em;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
    display: inline-block;
    min-width: 120px;
    text-align: center;
}

.contract-status.active {
    background: #10B981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
}

.contract-status:hover {
    transform: scale(1.05);
}

       .wallet-section {
    display: flex;
    align-items: center;
    gap: 15px;
    position: relative;
    z-index: 101; /* Выше чем уведомления */
}
         /* ДОБАВИТЬ СТИЛИ ДЛЯ КНОПКИ ПРОВЕРКИ БАЛАНСА */
#balanceCheckBtn {
    background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    border: 2px solid #1E293B;
    white-space: nowrap;
    position: relative;
    z-index: 102; /* Самая высокая позиция */
}

#balanceCheckBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
}

        .wallet-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .content-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .contract-stopped-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #EF4444;
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }

        .section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 2px solid #E2E8F0;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #1E293B;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 800;
            font-size: 1.2em;
        }

        .input-group {
            margin-bottom: 15px;
            position: relative;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
            color: #374151;
            font-size: 1.05em;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px 40px 12px 12px;
            border: 2px solid #D1D5DB;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
            font-family: monospace;
            font-weight: 600;
            background: #F9FAFB;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #8B5CF6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.15);
            background: #FFFFFF;
        }

        .clear-input {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6B7280;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
            display: none;
        }

        .clear-input:hover {
            background: #E5E7EB;
            color: #374151;
        }

        .btn {
            background: linear-gradient(135deg, #8B5CF6 0%, #06B6D4 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 4px;
            font-weight: 700;
            border: 2px solid #1E293B;
            transform: scale(1);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        .btn:disabled {
            background: #475569;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border-color: #64748B;
        }

        .btn-success {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
        }

        .hash-display {
            background: #F8FAFC;
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            word-break: break-all;
            margin: 10px 0;
            border: 2px solid #E5E7EB;
            min-height: 50px;
            position: relative;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .hash-masked {
            filter: blur(6px);
            transition: filter 0.3s ease;
            user-select: none;
        }

        .hash-visible {
            filter: none;
            user-select: text;
        }

        .hash-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .hash-controls .btn {
            padding: 8px 16px;
            font-size: 14px;
        }

        .file-upload {
            border: 2px dashed #D1D5DB;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background: #F8FAFC;
        }

        .file-upload:hover {
            border-color: #8B5CF6;
            background: #F3F4F6;
        }

        .file-upload.dragover {
            border-color: #10B981;
            background: #D1FAE5;
            animation: pulse 1s infinite;
        }

        .file-upload.file-selected {
            border-color: #10B981;
            background: #D1FAE5;
        }

        .file-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #E2E8F0;
            border-radius: 6px;
            display: none;
            transition: all 0.3s ease;
            font-weight: 600;
            border: 2px solid #CBD5E1;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #E2E8F0;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
            display: none;
            border: 2px solid #CBD5E1;
        }

        .progress {
            height: 100%;
            background: linear-gradient(135deg, #8B5CF6 0%, #06B6D4 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 10px 0;
        }

        .spinner {
            border: 4px solid #F3F4F6;
            border-top: 4px solid #8B5CF6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result {
            margin-top: 12px;
            padding: 12px;
            border-radius: 8px;
            display: none;
            transition: all 0.3s ease;
            font-weight: 600;
            border: 2px solid;
        }

        .result.success {
            background: #D1FAE5;
            border-color: #10B981;
            color: #065F46;
            display: block;
        }

        .result.error {
            background: #FEE2E2;
            border-color: #EF4444;
            color: #7F1D1D;
            display: block;
        }

        .result.info {
            background: #DBEAFE;
            border-color: #3B82F6;
            color: #1E40AF;
            display: block;
        }

        .security-warning {
            background: #FEF3C7;
            border: 2px solid #F59E0B;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            color: #92400E;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .security-warning h4 {
            margin-bottom: 8px;
            color: #92400E;
            font-weight: 800;
        }

        .fee-info {
            background: #FEF3C7;
            border: 2px solid #F59E0B;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 700;
        }

        .owner-section {
            display: none;
        }

        .owner-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-card {
            background: #F8FAFC;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #E2E8F0;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 4px;
            font-weight: 800;
        }

        .stat-label {
            font-size: 0.8em;
            opacity: 0.9;
            font-weight: 600;
        }

        .owner-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .control-card {
            background: #F8FAFC;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
            border: 2px solid #E2E8F0;
        }

        .control-card h4 {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 800;
        }

        .registration-mode-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .mode-btn {
            padding: 12px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
        }

        .mode-btn:hover {
            border-color: #8B5CF6;
            transform: translateY(-2px);
        }

        .mode-btn.active {
            border-color: #10B981;
            background: #D1FAE5;
        }

        .mode-btn.disabled {
            border-color: #EF4444;
            background: #FEE2E2;
            opacity: 0.7;
        }

        .current-mode {
            background: #DBEAFE;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            margin: 10px 0;
            border: 2px solid #3B82F6;
        }

        .mode-status {
            font-weight: 800;
            color: #1E40AF;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .notification {
    position: fixed;
    top: 80px; /* Смещаем ниже, чтобы не перекрывать кнопку баланса */
    right: 20px;
    padding: 15px 20px;
    border-radius: 8px;
    color: white;
    font-weight: 700;
    z-index: 1000;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    animation: fadeIn 0.3s ease;
    display: flex;
    align-items: center;
    gap: 10px;
    max-width: 400px;
    min-width: 300px;
}
     /* ДОБАВИТЬ НОВЫЕ СТИЛИ ДЛЯ ПРЕДУПРЕЖДЕНИЙ О БАЛАНСЕ */
.notification.warning {
    background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
    top: 120px; /* Еще ниже для предупреждений о балансе */
}

        .notification.success {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .notification.info {
            background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
        }

        .commit-reveal-status {
            background: #EFF6FF;
            border: 2px solid #3B82F6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }

        .commit-reveal-status.active {
            display: block;
        }

        .status-step {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
            background: #F8FAFC;
        }

        .status-step.completed {
            background: #D1FAE5;
            color: #065F46;
        }

        .status-step.active {
            background: #DBEAFE;
            color: #1E40AF;
            font-weight: bold;
        }

        .status-step.pending {
            background: #FEF3C7;
            color: #92400E;
        }

        .step-icon {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .timer {
            font-family: monospace;
            font-weight: bold;
            color: #DC2626;
            margin-left: auto;
        }

        .reveal-countdown {
            text-align: center;
            padding: 10px;
            background: #FEF3C7;
            border-radius: 6px;
            margin: 10px 0;
            border: 2px solid #F59E0B;
        }

        .countdown-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #DC2626;
        }

        .protection-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .protection-option {
            background: white;
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #E5E7EB;
            text-align: center;
        }

        .protection-option:hover {
            border-color: #8B5CF6;
            transform: translateY(-3px);
        }

        .protection-option.active {
            border-color: #10B981;
            background: #D1FAE5;
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }

        .protection-option.disabled {
            border-color: #EF4444;
            background: #FEE2E2;
            opacity: 0.7;
            cursor: not-allowed;
        }

        .protection-title {
            font-weight: 800;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .protection-desc {
            margin-bottom: 10px;
            color: #6B7280;
        }

        .protection-cost {
            font-weight: 700;
            color: #059669;
            margin-bottom: 10px;
        }

        .salt-display, .commit-hash-display {
            background: #F8FAFC;
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            word-break: break-all;
            margin: 10px 0;
            border: 2px solid #E5E7EB;
            min-height: 50px;
        }

        .commit-info {
            background: #EFF6FF;
            border: 2px solid #3B82F6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .commit-details {
            font-family: monospace;
            font-size: 0.9em;
            margin-top: 8px;
        }

        .verification-result, .transfer-result {
            background: #F8FAFC;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px solid #E2E8F0;
        }

        .verification-details, .transfer-details {
            font-family: monospace;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .verified-badge {
            background: #10B981;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 700;
        }

        .not-verified-badge {
            background: #EF4444;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 700;
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
            }
            
            .nav-menu {
                display: flex;
                overflow-x: auto;
            }
            
            .nav-item {
                white-space: nowrap;
                border-left: none;
                border-bottom: 3px solid transparent;
            }
            
            .nav-item.active {
                border-left: none;
                border-bottom-color: #8B5CF6;
            }
            
            .protection-options {
                grid-template-columns: 1fr;
            }
            
            .mode-buttons {
                grid-template-columns: 1fr;
            }
        }

        .operation-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .operation-controls .btn {
            padding: 10px 16px;
            font-size: 14px;
            border-radius: 8px;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 160px;
        }

        .operation-controls .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .operation-controls .btn:active {
            transform: scale(0.95);
        }

        .validation-message {
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9em;
            display: none;
        }

        .validation-error {
            background: #FEE2E2;
            color: #7F1D1D;
            border: 1px solid #EF4444;
        }

        .input-hint {
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9em;
            display: none;
            background: #FEF3C7;
            color: #92400E;
            border: 1px solid #F59E0B;
        }

        .reminder-note {
            background: #EFF6FF;
            border: 2px solid #3B82F6;
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #1E40AF;
        }

        .reminder-note h5 {
            margin-bottom: 8px;
            color: #1E40AF;
            font-weight: 800;
        }

        .report-ready-indicator {
            background: #D1FAE5;
            border: 2px solid #10B981;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: 700;
            color: #065F46;
        }

        .info-section {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 2px solid #E2E8F0;
        }

        .info-section h3 {
            margin-bottom: 20px;
            color: #1E293B;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 800;
            font-size: 1.4em;
        }

        .info-content {
            line-height: 1.6;
            font-size: 1.05em;
        }

        .info-content h4 {
            margin: 25px 0 15px 0;
            color: #374151;
            font-weight: 800;
            font-size: 1.2em;
        }

        .info-content p {
            margin-bottom: 15px;
            color: #4B5563;
        }

        .info-content ul, .info-content ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        .info-content li {
            margin-bottom: 8px;
            color: #4B5563;
        }

        .info-content strong {
            color: #1E293B;
            font-weight: 800;
        }

        .info-content .highlight {
            background: linear-gradient(135deg, #FEF3C7 0%, #FEF7CD 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #F59E0B;
            margin: 20px 0;
        }

        .info-content .example {
            background: #F8FAFC;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #E2E8F0;
            margin: 15px 0;
            font-family: monospace;
        }

        .info-content .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .feature-card {
            background: #F8FAFC;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #E2E8F0;
        }

        .feature-card h5 {
            margin-bottom: 10px;
            color: #1E293B;
            font-weight: 800;
        }

        .feature-card p {
            margin: 0;
            color: #4B5563;
        }

        .welcome-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            text-align: center;
            background: linear-gradient(135deg, #7C3AED 0%, #0891B2 100%);
            color: white;
        }

        .welcome-title {
            font-size: 3.5em;
            font-weight: 800;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .welcome-subtitle {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .welcome-version {
            font-size: 1.2em;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .welcome-instruction {
            margin-top: 40px;
            font-size: 1.1em;
            opacity: 0.8;
            max-width: 500px;
        }

        .agreement-section {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 2px solid #E2E8F0;
        }

        .agreement-content {
            line-height: 1.6;
            font-size: 1.05em;
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .agreement-item {
            margin-bottom: 15px;
            padding: 10px;
            border-left: 4px solid #8B5CF6;
            background: #F8FAFC;
        }

        .agreement-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: #FEF3C7;
            border-radius: 8px;
            border: 2px solid #F59E0B;
        }

        .agreement-checkbox input {
            width: 20px;
            height: 20px;
        }

        .agreement-checkbox label {
            font-weight: 700;
            color: #92400E;
        }

        .agreement-button {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        .wallet-option {
            padding: 15px;
            border: 2px solid #E2E8F0;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px 0;
        }

        .wallet-option:hover {
            border-color: #8B5CF6;
            transform: translateY(-2px);
        }

        .install-guide {
            text-align: left;
            margin: 20px 0;
            padding: 15px;
            background: #F8FAFC;
            border-radius: 8px;
        }

        /* Стили для контакта разработчика */
        .developer-contact {
            text-align: center;
            padding: 15px;
            margin: 10px 15px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .developer-contact a {
            color: #60a5fa;
            text-decoration: none;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .developer-contact a:hover {
            color: #3b82f6;
            transform: translateY(-1px);
        }

    /* Стили для подписей полей тарифов */
.fee-currency {
    position: absolute;
    right: 40px;
    top: 50%;
    transform: translateY(-50%);
    color: #6B7280;
    font-weight: 600;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.8);
    padding: 2px 6px;
    border-radius: 4px;
}

.input-group label {
    display: block;
    margin-bottom: 6px;
    font-weight: 700;
    color: #374151;
    font-size: 1.05em;
    line-height: 1.3; /* Добавляем для лучшего отображения длинного текста */
}

.fee-input {
    padding-right: 70px !important;
}

/* Увеличиваем правый отступ для полей с длинными подписями */
.input-group {
    position: relative;
}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
</head>
<body>
     <!-- Языковая панель - Космический блокчейн -->
<div class="language-selector" id="languageSelector">
    <!-- Контейнер для анимированных звёзд -->
    <div class="stars" id="starsContainer"></div>
    
    <div class="app-title-large">DIGITAL NOTARIUS</div>
    <div class="app-version">VER. 5.0</div>
    
    <div class="language-buttons">
        <button class="lang-btn active" onclick="selectLanguage('ru')">
             РУССКИЙ
        </button>
        <button class="lang-btn" id="englishBtn" onclick="selectLanguage('en')">
             ENGLISH
        </button>
    </div>
    
    <div class="language-hint" id="languageHint">
        Выберите язык интерфейса / Select interface language
    </div>
</div>

      <!-- Модальное окно покупки токенов -->
    <div class="buy-tokens-modal" id="buyTokensModal">
        <div class="buy-tokens-content">
            <h3>🪙 Purchase Native Tokens</h3>
            <div class="balance-check" id="currentBalanceCheck">
                <span>Your current balance:</span>
                <span class="balance-status" id="currentBalanceDisplay">Checking...</span>
            </div>
            
            <div class="quick-buy-section">
                <h4>Quick Purchase</h4>
                <p>Select the amount you want to buy:</p>
                
                <div class="token-options">
                    <div class="token-option" data-amount="0.01" onclick="selectTokenAmount(0.01)">
                        <div class="token-amount">0.01 <span id="tokenSymbol">ETH</span></div>
                        <div class="token-price">~ $<span id="price001">-</span></div>
                    </div>
                    <div class="token-option" data-amount="0.05" onclick="selectTokenAmount(0.05)">
                        <div class="token-amount">0.05 <span id="tokenSymbol">ETH</span></div>
                        <div class="token-price">~ $<span id="price005">-</span></div>
                    </div>
                    <div class="token-option" data-amount="0.1" onclick="selectTokenAmount(0.1)">
                        <div class="token-amount">0.1 <span id="tokenSymbol">ETH</span></div>
                        <div class="token-price">~ $<span id="price01">-</span></div>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <label>Custom amount:</label>
                    <input type="number" id="customAmount" placeholder="0.0" step="0.001" min="0.001" 
                           style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #E2E8F0; border-radius: 8px;">
                </div>
            </div>

            <div class="balance-warning" id="purchaseWarning" style="display: none;">
                <strong>⚠️ Important:</strong> You need native tokens to pay for network fees
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-success" id="proceedWithPurchase" onclick="proceedWithPurchase()" style="flex: 1;">
                    🛒 Buy Tokens
                </button>
                <button class="btn btn-warning" onclick="skipPurchase()" style="flex: 1;">
                    ⏭️ Skip
                </button>
            </div>
            
            <button class="btn" onclick="closeBuyTokensModal()" style="width: 100%; margin-top: 10px;">
                Cancel
            </button>
        </div>
    </div>

    <div class="contract-stopped-message" id="contractStoppedMessage" style="display: none;">
       <h2 data-translate="contractStoppedTitle">⚠️ КОНТРАКТ ОСТАНОВЛЕН</h2>
       <p data-translate="contractStoppedMessage1">Контракт временно приостановлен владельцем.</p>
       <p data-translate="contractStoppedMessage2">Регистрация контента временно недоступна.</p>
    </div>

    <div class="app-container">
        <div class="sidebar">
            <div class="app-title">🔏 Digital Notary</div>
            <div class="nav-menu">
                <div class="nav-item" data-tab="about">
                     <span data-translate="navAbout">О приложении</span>
                </div>
                <div class="nav-item" data-tab="purpose">
                     <span data-translate="navPurpose">Для чего нужно</span>
                </div>
                <div class="nav-item" data-tab="howItWorks">
                    <span data-translate="navHowItWorks">Как это работает</span>
                </div>
                
                <div class="nav-item client-only" data-tab="agreement" id="agreementNavItem">
                     <span data-translate="navAgreement">Соглашение</span>
                </div>
                
                <div class="nav-item user-only" data-tab="registration" id="registrationNavItem">
                     <span data-translate="navRegistration">Регистрация </span>
                </div>
                <div class="nav-item user-only" data-tab="verification" id="verificationNavItem">
                     <span data-translate="navVerification">проверка Регистрации/span>
                </div>
                <div class="nav-item user-only" data-tab="transfer" id="transferNavItem">
                     <span data-translate="navTransfer">Передача прав</span>
                </div>
                <div class="nav-item owner-only" data-tab="owner" id="ownerNavItem">
                    <span>👑</span> <span data-translate="navOwner">Панель владельца</span>
                </div>
            </div>

            <!-- Контакт разработчика -->
            <div class="developer-contact">
                <a href="https://t.me/Tramp_bit" target="_blank" title="Написать разработчику в Telegram / Contact developer on Telegram">
                    <span data-translate="developerContact">owner</span>
                    <span>@Tramp_bit</span>
                </a>
            </div>

            <div class="current-network-display">
                <div class="current-network-name" id="currentNetworkName" data-translate="networkNotConnected">Не подключен</div>
                <div class="current-network-status" id="networkStatus" data-translate="selectNetwork">Выберите сеть</div>
                <button class="btn btn-info" id="switchNetworkBtn" style="width: 100%; margin-top: 10px; padding: 8px; font-size: 0.8em;" data-translate="switchNetwork">
                    🔄 Сменить сеть
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="header">
                <h1 data-translate="appTitle">Digital Notary DApp</h1>
                <div class="contract-status" id="contractStatus" data-translate="contractStatusUnknown">Неизвестно</div>
                <div class="wallet-section">
                    <button class="btn" id="connectWallet" data-translate="connectWallet">📱 Подключить MetaMask</button>
                    <div class="wallet-info" id="walletInfo" style="display: none;">
                        <span id="walletAddress"></span> | <span id="walletBalance">0 ETH</span>
                    </div>
                </div>
            </div>

            <div class="content-area">
                <div class="welcome-screen" id="welcomeScreen">
                    <div class="welcome-title">DIGITAL NOTARY</div>
                    <div class="welcome-subtitle" data-translate="welcomeSubtitle">Децентрализованный цифровой нотариус</div>
                    <div class="welcome-version">VER. 5.0</div>
                    <div class="welcome-instruction" id="welcomeInstruction"></div>
                </div>

                <!-- Информационные вкладки -->
                <div class="tab-content" id="aboutTab">
                    <div class="info-section">
                        <h3><span data-translate="aboutApp">О приложении</span></h3>
                        <div class="info-content">
                            <h4 data-translate="whatIsBlockchain">Что такое блокчейн</h4>
                            <p><strong data-translate="blockchainDefinition">Блокчейн</strong> <span data-translate="blockchainDescription">— это распределённая база данных, где каждая запись хранится навсегда. Каждый новый блок навсегда связывается с предыдущим, и изменить прошлое невозможно без разрушения всей цепочки. Это делает блокчейн неизменяемым, надёжным и абсолютно прозрачным источником данных.</span></p>
                            
                            <div class="highlight">
                                <h4 data-translate="whyBlockchainPerfect">Почему блокчейн — идеальное решение для цифрового нотариата</h4>
                                <div class="feature-grid">
                                    <div class="feature-card">
                                        <h5>✅ <span data-translate="immutability">Неизменность</span></h5>
                                        <p data-translate="immutabilityDesc">Данные невозможно подделать или удалить</p>
                                    </div>
                                    <div class="feature-card">
                                        <h5>✅ <span data-translate="forever">Навсегда</span></h5>
                                        <p data-translate="foreverDesc">Запись остаётся в блокчейне навсегда, даже если приложение или сайт исчезнет</p>
                                    </div>
                                    <div class="feature-card">
                                        <h5>✅ <span data-translate="verifiability">Проверяемость</span></h5>
                                        <p data-translate="verifiabilityDesc">Любой человек в мире может убедиться в существовании записи, независимо от третьих лиц</p>
                                    </div>
                                    <div class="feature-card">
                                        <h5>✅ <span data-translate="noIntermediaries">Отсутствие посредников</span></h5>
                                        <p data-translate="noIntermediariesDesc">Всё происходит напрямую между вами и сетью блокчейна</p>
                                    </div>
                                </div>
                            </div>
                            
                            <h4 data-translate="whatAppDoes">Что делает это приложение</h4>
                            <p><strong data-translate="appName">Digital Notary DApp</strong> <span data-translate="appDescription">— это децентрализованный цифровой нотариус. Вы можете зафиксировать факт владения любым вашим цифровым контентом: документом, фото, видео, песней, стихом, проектом, контрактом, изобретением и т.д. Одна минута — и право на ваш контент зафиксировано навсегда.</span></p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="purposeTab">
                    <div class="info-section">
                        <h3>🎯 <span data-translate="purposeTitle">Для чего нужно приложение</span></h3>
                        <div class="info-content">
                            <h4 data-translate="whatIsUsedFor">Для чего используется</h4>
                            <p><strong data-translate="appName">Digital Notary DApp</strong> <span data-translate="purposeDescription">нужен, чтобы доказать ваше авторство и право владения цифровым контентом. Любой контент, который вы создали, может быть закреплён в блокчейне с отметкой времени и вашим адресом. Это — ваш цифровой нотариус, работающий без людей, без нотариусов и без доверия к кому-либо.</span></p>
                            
                            <h4 data-translate="examplesWhereVital">Примеры, где это жизненно важно:</h4>
                            <div class="feature-grid">
                                <div class="feature-card">
                                    <h5>📘 <span data-translate="basicRegistration">Базовая регистрация (одна транзакция)</span></h5>
                                    <p data-translate="basicRegistrationDesc">Подходит, если вы хотите просто зафиксировать факт владения контентом:</p>
                                    <ul>
                                        <li data-translate="basicRegistrationItem1">тексты, статьи, заметки, публикации</li>
                                        <li data-translate="basicRegistrationItem2">фотографии, иллюстрации, рисунки</li>
                                        <li data-translate="basicRegistrationItem3">песни, музыка, стихи</li>
                                        <li data-translate="basicRegistrationItem4">черновики, наброски, идеи</li>
                                        <li data-translate="basicRegistrationItem5">деловые документы, договора, инструкции</li>
                                        <li data-translate="basicRegistrationItem6">завещания, письма, заявления, рецепты</li>
                                    </ul>
                                    <p><strong data-translate="whenToUse">Когда использовать:</strong> <span data-translate="basicRegistrationUsage">если контент не требует скрытия содержания (в момент регистрации в блокчейне) и может быть зафиксирован напрямую.</span></p>
                                </div>
                                <div class="feature-card">
                                    <h5>🔒 <span data-translate="commitRevealRegistration">Коммит–ревеал регистрация (две транзакции)</span></h5>
                                    <p data-translate="commitRevealDesc">Подходит для ценных, конфиденциальных или коммерческих материалов:</p>
                                    <ul>
                                        <li data-translate="commitRevealItem1">патенты, изобретения, исследования</li>
                                        <li data-translate="commitRevealItem2">сценарии, тексты до публикации</li>
                                        <li data-translate="commitRevealItem3">проекты, коммерческие предложения, контракты</li>
                                        <li data-translate="commitRevealItem4">стратегические документы, исходные коды, AI-модели</li>
                                    </ul>
                                    <p><strong data-translate="advantage">Преимущество:</strong> <span data-translate="commitRevealAdvantage">Сначала вы фиксируете "обещание" (коммит), не раскрывая контент, а потом раскрываете его (ревеал). Если коммит уже Ваш в блокчейн-то ревеал гарантированно Ваш. Это гарантирует двойную защиту-никто не узнает, что именно вы регистрировали, пока вы сами не раскроете.</span></p>
                                </div>
                            </div>
                            
                            <div class="highlight">
                                <h4 data-translate="whyImportant">Почему это важно</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                                    <div style="background: #D1FAE5; padding: 15px; border-radius: 8px; border-left: 4px solid #10B981;">
                                        <strong>📜 <span data-translate="confirmsAuthorship">Подтверждает авторство</span></strong><br><span data-translate="confirmsAuthorshipDesc">в любой момент времени</span>
                                    </div>
                                    <div style="background: #DBEAFE; padding: 15px; border-radius: 8px; border-left: 4px solid #3B82F6;">
                                        <strong>⚖️ <span data-translate="courtEvidence">Доказательство в суде</span></strong><br><span data-translate="courtEvidenceDesc">может использоваться как юридическое доказательство</span>
                                    </div>
                                    <div style="background: #FEF3C7; padding: 15px; border-radius: 8px; border-left: 4px solid #F59E0B;">
                                        <strong>💼 <span data-translate="plagiarismProtection">Защита от плагиата</span></strong><br><span data-translate="plagiarismProtectionDesc">и кражи контента</span>
                                    </div>
                                    <div style="background: #EDE9FE; padding: 15px; border-radius: 8px; border-left: 4px solid #8B5CF6;">
                                        <strong>⏳ <span data-translate="fixesDate">Фиксирует дату</span></strong><br><span data-translate="fixesDateDesc">создания навсегда</span>
                                    </div>
                                    <div style="background: #FCE7F3; padding: 15px; border-radius: 8px; border-left: 4px solid #EC4899;">
                                        <strong>🧾 <span data-translate="rightsTransfer">Передача прав</span></strong><br><span data-translate="rightsTransferDesc">официально и прозрачно</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="howItWorksTab">
                    <div class="info-section">
                        <h3>⚙️ <span data-translate="howItWorksTitle">Как это работает</span></h3>
                        <div class="info-content">
                            <h4 data-translate="principle">Принцип</h4>
                            <p data-translate="principleDesc1">У вас есть контент, то есть всё, что имеет цифровую форму: тексты, документы, фото, видео, музыка, контракты, завещания — всё, что уникально и принадлежит вам.</p>
                            <p data-translate="principleDesc2">С помощью Digital Notary DApp вы создаёте уникальный цифровой отпечаток (хэш) этого контента, который записывается в блокчейн и навсегда закрепляется за вашим адресом. Никто не сможет изменить, удалить или оспорить это право.</p>
                            
                            <div class="feature-grid">
                                <div class="feature-card">
                                    <h4>🔹 <span data-translate="contentRegistration">Регистрация контента</span></h4>
                                    <ol>
                                        <li data-translate="registrationStep1">Перейдите в раздел <strong data-translate="registration">Регистрация</strong></li>
                                        <li data-translate="registrationStep2">Выберите метод — <strong data-translate="basic">Базовый</strong> или <strong data-translate="commitReveal">Коммит–Ревеал</strong></li>
                                        <li data-translate="registrationStep3">Загрузите ваш файл или документ</li>
                                        <li data-translate="registrationStep4">Все вычисления (хэш, коммит-хэш, соль) выполняются автоматически</li>
                                        <li data-translate="registrationStep5">Подтвердите транзакцию в вашем кошельке</li>
                                        <li data-translate="registrationStep6">После успешной регистрации получите отчёт</li>
                                        <li data-translate="registrationStep7">Вы можете его скопировать или скачать</li>
                                    </ol>
                                    <div class="reminder-note">
                                        <h5>💡 <span data-translate="ifReportLost">Если вы не сохранили отчёт:</span></h5>
                                        <p data-translate="ifReportLostDesc">Не страшно — вы можете всегда вычислить хэш вашего контента заново и в разделе <strong data-translate="verification">Верификация</strong> получить новый отчёт.</p>
                                    </div>
                                </div>
                                <div class="feature-card">
                                    <h4>🔹 <span data-translate="commitRevealRegistration">Коммит–Ревеал регистрация (двойная защита)</span></h4>
                                    <ol>
                                        <li data-translate="commitRevealStep1">Нажмите <strong data-translate="commitRegistration">Коммит Регистрация</strong> — выполняется первая фиксация</li>
                                        <li data-translate="commitRevealStep2">После подтверждения дождитесь небольшой задержки (задана владельцем)</li>
                                        <li data-translate="commitRevealStep3">Нажмите <strong data-translate="revealRegistration">Ревеал Регистрация</strong> — раскрывается контент и право закрепляется окончательно</li>
                                        <li data-translate="commitRevealStep4">Получите отчёт с деталями транзакции</li>
                                    </ol>
                                </div>
                            </div>
                            
                            <div class="feature-grid">
                                <div class="feature-card">
                                    <h4>🔹 <span data-translate="contentVerification">Проверка контента (верификация)</span></h4>
                                    <ol>
                                        <li data-translate="verificationStep1">Перейдите в раздел <strong data-translate="verification">Верификация</strong></li>
                                        <li data-translate="verificationStep2">Вставьте хэш контента, который хотите проверить</li>
                                        <li data-translate="verificationStep3">Нажмите <strong data-translate="check">Проверить</strong></li>
                                        <li data-translate="verificationStep4">Если контент зарегистрирован — вы увидите подтверждение и сможете получить отчёт</li>
                                        <li data-translate="verificationStep5">Если не зарегистрирован — появится сообщение, что записи нет в блокчейне, и вы сможете сохранить отчёт об этом факте</li>
                                    </ol>
                                </div>
                                <div class="feature-card">
                                    <h4>🔹 <span data-translate="rightsTransfer">Передача прав на контент</span></h4>
                                    <ol>
                                        <li data-translate="transferStep1">Перейдите в раздел <strong data-translate="transfer">Передача прав</strong></li>
                                        <li data-translate="transferStep2">Вставьте хэш зарегистрированного контента</li>
                                        <li data-translate="transferStep3">Введите адрес нового владельца (адрес Ethereum-аккаунта)</li>
                                        <li data-translate="transferStep4">Если всё введено корректно — кнопка станет активной</li>
                                        <li data-translate="transferStep5">Подтвердите транзакцию</li>
                                        <li data-translate="transferStep6">После успешной передачи получите отчёт о передаче прав</li>
                                    </ol>
                                    <div class="security-warning">
                                        <h5>⚠️ <span data-translate="attention">Внимание:</span></h5>
                                        <p data-translate="transferWarning">Контракт не позволяет передавать контент самому себе, на нулевой адрес или на контрактные адреса. Ответственность за корректность введённого адреса полностью лежит на пользователе.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="highlight" style="background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%); border-left: 4px solid #F59E0B;">
                                <h4>💬 <span data-translate="andMostImportant">И главное</span></h4>
                                <p><strong data-translate="rightsFixedForever">Ваше право на контент зафиксировано навсегда.</strong><br>
                                <span data-translate="noOneCanChange">Никакой администратор, нотариус или третье лицо не может это изменить или удалить.</span><br>
                                <span data-translate="yourDigitalProof">Ваш хэш и ваш адрес в блокчейне — это ваше цифровое доказательство собственности.</span></p>
                            </div>
                        </div>
                    </div>
                </div>

                    <!-- Вкладка соглашения -->
<div class="tab-content client-only" id="agreementTab">
    <div class="agreement-section">
        <h3> <span data-translate="userAgreement">Пользовательское соглашение</span></h3>
        <div class="agreement-content">
            <div class="agreement-item">
                <h4 data-translate="agreementItem1Title">1. Блокчейн - это технология будущего и оно уже для вас наступило</h4>
                <p data-translate="agreementItem1Desc">Блокчейн представляет собой децентрализованную, распределенную и неизменяемую базу данных, которая обеспечивает прозрачность, безопасность и надежность всех операций. Используя это приложение, вы становитесь частью новой цифровой эпохи, где доверие обеспечивается технологией, а не посредниками.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem2Title">2. Хэш вашего контента - это цифровой отпечаток пальцев, который для одного контента всегда одинаков</h4>
                <p data-translate="agreementItem2Desc">Хэш-функция SHA-256 создает уникальный цифровой отпечаток вашего контента. Любое, даже самое незначительное изменение в контенте приведет к совершенно другому хэшу. Это гарантирует, что каждый контент имеет уникальный идентификатор, который невозможно подделать.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem3Title">3. Хэш и адрес вашего аккаунта в любой сети/блокчейн - это ключи доступа к ячейке, где лежит ваша регистрация</h4>
                <p data-translate="agreementItem3Desc">Хэш контента и ваш адрес Ethereum-кошелька вместе формируют уникальную пару, которая идентифицирует ваше право собственности на контент в блокчейне. Без этих данных невозможно доказать или проверить ваши права.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem4Title">4. Зарегистрированное право неоспоримо и неизменимо никогда</h4>
                <p data-translate="agreementItem4Desc">После регистрации контента в блокчейне запись становится неизменной и вечной. Никто, включая разработчиков приложения или владельцев контракта, не может изменить или удалить вашу регистрацию. Это обеспечивает абсолютную защиту ваших прав.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem5Title">5. Храните сид-фразы от аккаунтов кошельков в недоступных местах и никогда не фотографируйте и не пересылайте</h4>
                <p data-translate="agreementItem5Desc">Сид-фраза (seed phrase) - это единственный способ восстановить доступ к вашему кошельку. Потеря сид-фразы означает безвозвратную потерю доступа ко всем зарегистрированным правам и средствам. Никогда не храните сид-фразу в цифровом виде и не передавайте ее третьим лицам.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem6Title">6. Никогда не вводите вручную адреса, только копируйте и вставляйте</h4>
                <p data-translate="agreementItem6Desc">Ошибка даже в одном символе адреса Ethereum может привести к безвозвратной потере прав или средств. Всегда используйте функцию копирования и вставки для работы с адресами и хэшами.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem7Title">7. Операции передачи права на контент необратимы, всегда проверяйте корректность адреса получателя права</h4>
                <p data-translate="agreementItem7Desc">После подтверждения транзакции передачи прав операция становится необратимой. Тщательно проверяйте адрес получателя перед подтверждением операции.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem8Title">8. Всегда используйте для особо ценного контента метод коммит-ревеал, он предотвращает кражу права на контент при регистрации на моменте когда транзакция в мемпуле и ждет обработки</h4>
                <p data-translate="agreementItem8Desc">Метод Commit-Reveal обеспечивает дополнительную защиту от front-running атак, когда злоумышленники могут попытаться перехватить вашу транзакцию в мемпуле и зарегистрировать контент на свой адрес.</p>
            </div>
            <div class="agreement-item">
                <h4 data-translate="agreementItem9Title">9. Внимательно изучите разделы меню "О приложении", "Для чего нужно" и "Как это работает"</h4>
                <p data-translate="agreementItem9Desc">Перед использованием приложения настоятельно рекомендуется внимательно изучить все информационные разделы, чтобы полностью понимать принципы работы и возможные риски.</p>
            </div>
        </div>
        <div class="agreement-checkbox">
            <input type="checkbox" id="agreeCheckbox">
            <label for="agreeCheckbox" data-translate="agreeCheckboxLabel">Я подтверждаю, что внимательно прочитал(а) и полностью понимаю все положения данного соглашения, и соглашаюсь с ними</label>
        </div>
        <button class="btn btn-success agreement-button" id="acceptAgreement" disabled data-translate="acceptAgreement">Принять соглашение</button>
    </div>
</div>

                <!-- Функциональные вкладки -->
                <div class="tab-content" id="registrationTab">
                    <div class="section">
                        <h3>📄 <span data-translate="contentRegistration">Регистрация контента</span></h3>
                        <div class="protection-options" id="protectionOptions">
                            <div class="protection-option active" data-protection="BASIC">
                                <div class="protection-title">⚡ <span data-translate="basicRegistration">Базовая регистрация</span></div>
                                <div class="protection-desc" data-translate="basicRegistrationDescShort">Мгновенная регистрация контента в блокчейне</div>
                                <div class="protection-cost" id="basicFeeDisplay" data-translate="fee">Комиссия: -</div>
                            </div>
                            <div class="protection-option" data-protection="COMMIT_REVEAL">
                                <div class="protection-title">🛡️ <span data-translate="commitReveal">Commit-Reveal</span></div>
                                <div class="protection-desc" data-translate="commitRevealDescShort">Максимальная защита от front-running атак</div>
                                <div class="protection-cost" id="commitRevealFeeDisplay" data-translate="fee">Комиссия: -</div>
                            </div>
                        </div>

                        <div class="result error" id="registrationMethodWarning" style="display: none;">
                            <strong>⚠️ <span data-translate="attention">Внимание:</span></strong> <span id="registrationMethodMessage"></span>
                        </div>

                        <div class="commit-reveal-status" id="commitRevealStatus">
                            <h4>🛡️ <span data-translate="commitRevealProcess">Процесс Commit-Reveal</span></h4>
                            <div class="status-step" id="step1">
                                <span class="step-icon">⏳</span>
                                <span data-translate="commitPhase">Фаза Commit: Ожидание подтверждения транзакции</span>
                                <span class="timer" id="commitTimer">-</span>
                            </div>
                            <div class="status-step" id="step2">
                                <span class="step-icon">⏰</span>
                                <span data-translate="revealDelayWait">Ожидание задержки reveal:</span> <span id="blocksRemaining">-</span> <span data-translate="blocks">блоков</span>
                                <span class="timer" id="revealTimer">-</span>
                            </div>
                            <div class="reveal-countdown" id="revealCountdown" style="display: none;">
                                <h4>⏰ <span data-translate="waitingReveal">Ожидание Reveal</span></h4>
                                <div class="countdown-number" id="countdownNumber">0</div>
                                <p data-translate="blocksUntilReveal">блоков до возможности раскрытия</p>
                            </div>
                            <div class="commit-info" id="commitInfo" style="display: none;">
                                <h4>📋 <span data-translate="commitInfo">Информация о коммите</span></h4>
                                <div class="commit-details" id="commitDetails"></div>
                            </div>
                        </div>

                        <div class="security-warning">
                            <h4>⚠️ <span data-translate="important">ВАЖНО:</span> <span data-translate="secureHashStorage">Безопасное хранение хэша</span></h4>
                            <p data-translate="hashIsFingerprint">Хэш - это цифровой отпечаток вашего файла. Сохраните его в надежном месте.</p>
                        </div>

                        <div class="file-upload" id="fileUpload">
                            <p data-translate="dragFileHere">📎 Перетащите файл сюда или нажмите для выбора</p>
                            <p><small data-translate="supportedFiles">Поддерживаются любые файлы: документы, изображения, видео и т.д.</small></p>
                            <input type="file" class="file-input" id="fileInput">
                        </div>
                        
                        <div class="progress-bar" id="progressBar">
                            <div class="progress" id="progress"></div>
                        </div>
                        
                        <div class="file-info" id="fileInfo">
                            <strong data-translate="selectedFile">Выбран файл:</strong> <span id="fileName"></span><br>
                            <strong data-translate="size">Размер:</strong> <span id="fileSize"></span><br>
                            <strong data-translate="type">Тип:</strong> <span id="fileType"></span>
                        </div>
                        
                        <div class="input-group">
                            <label data-translate="contentHash">Хэш контента (SHA-256):</label>
                            <div class="hash-display hash-masked" id="contentHashDisplay" data-translate="hashWillBeCalculated">
                                Хэш будет вычислен автоматически после выбора файла
                            </div>
                            <div class="hash-controls" id="hashControls" style="display: none;">
                                <button class="btn btn-warning" id="toggleHash" data-translate="showHash">Показать хэш</button>
                                <button class="btn btn-success" id="copyHash" data-translate="copyHash">Копировать хэш</button>
                            </div>
                        </div>

                        <div class="input-group" id="saltGroup" style="display: none;">
                            <label data-translate="salt">Соль (случайное значение):</label>
                            <div class="salt-display" id="saltDisplay" data-translate="saltWillBeGenerated">
                                Соль будет сгенерирована автоматически
                            </div>
                        </div>

                        <div class="input-group" id="commitHashGroup" style="display: none;">
                            <label data-translate="commitHash">Хэш коммита:</label>
                            <div class="commit-hash-display" id="commitHashDisplay" data-translate="commitHashWillBeCalculated">
                                Хэш коммита будет вычислен автоматически
                            </div>
                        </div>

                        <button class="btn btn-success" id="registerContent" disabled data-translate="registerContent">Зарегистрировать контент</button>
                        <button class="btn btn-info" id="revealContent" style="display: none;" disabled data-translate="revealContent">Раскрыть контент (Reveal)</button>
                        
                        <div class="loading" id="registerLoading">
                            <div class="spinner"></div>
                            <p data-translate="registrationInProgress">Регистрация в процессе...</p>
                        </div>
                        
                        <div class="result" id="registerResult"></div>
                    </div>
                </div>

                <div class="tab-content" id="verificationTab">
                    <div class="section">
                        <h3>🔍 <span data-translate="registrationVerification">Проверка регистрации</span></h3>
                        <div class="fee-info">
                            <strong data-translate="verificationFee">Комиссия за проверку:</strong> <span id="verificationFeeDisplay">-</span>
                        </div>
                        
                        <div class="input-group">
                            <label data-translate="enterHashForVerification">Введите хэш для проверки:</label>
                            <input type="text" id="verifyHash" placeholder="" 
                                   style="font-family: monospace;" autocomplete="off"
                                   pattern="[a-fA-F0-9]{64}" maxlength="64">
                            <button class="clear-input" id="clearVerifyHash" title="" data-translate="clearField">✕</button>
                            <div class="input-hint" id="verifyHashHint">
                                ⚠️ <span data-translate="doNotEnterManually">Не вводите вручную, используйте копирование и вставку</span>
                            </div>
                        </div>
                        
                        <button class="btn btn-warning" id="verifyContent" disabled data-translate="verifyRegistration">Проверить регистрацию</button>
                        
                        <div class="loading" id="verifyLoading">
                            <div class="spinner"></div>
                            <p data-translate="verificationInProgress">Проверка в процессе...</p>
                        </div>
                        
                        <div class="result" id="verifyResult"></div>
                    </div>
                </div>

                <div class="tab-content" id="transferTab">
                    <div class="section">
                        <h3>🔄 <span data-translate="rightsTransfer">Передача прав на контент</span></h3>
                        <div class="fee-info">
                            <strong data-translate="transferFee">Комиссия за передачу прав:</strong> <span id="transferFeeDisplay">-</span>
                        </div>
                        
                        <div class="security-warning">
                            <h4>⚠️ <span data-translate="important">ВАЖНО:</span> <span data-translate="rightsTransfer">Передача прав</span></h4>
                            <ul>
                                <li data-translate="transferWarning1">После передачи прав вы теряете все права на контент</li>
                                <li data-translate="transferWarning2">Операция необратима и записывается в блокчейн</li>
                                <li data-translate="transferWarning3">Нельзя передавать права самому себе</li>
                            </ul>
                        </div>
                        
                        <div class="input-group">
                            <label data-translate="contentHashYouOwn">Хэш контента (которым вы владеете):</label>
                            <input type="text" id="transferHash" placeholder="" 
                                   style="font-family: monospace;" autocomplete="off"
                                   pattern="[a-fA-F0-9]{64}" maxlength="64">
                            <button class="clear-input" id="clearTransferHash" title="" data-translate="clearField">✕</button>
                            <div class="input-hint" id="transferHashHint">
                                ⚠️ <span data-translate="doNotEnterManually">Не вводите вручную, используйте копирование и вставку</span>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label data-translate="newOwnerAddress">Адрес нового владельца:</label>
                            <input type="text" id="newOwnerAddress" placeholder="0x..." 
                                   style="font-family: monospace;" autocomplete="off"
                                   pattern="^0x[a-fA-F0-9]{40}$">
                            <button class="clear-input" id="clearNewOwner" title="" data-translate="clearField">✕</button>
                            <div class="input-hint" id="newOwnerAddressHint">
                                ⚠️ <span data-translate="doNotEnterManually">Не вводите вручную, используйте копирование и вставку</span>
                            </div>
                            <div class="validation-message" id="newOwnerAddressValidation"></div>
                        </div>
                        
                        <button class="btn btn-warning" id="transferOwnership" disabled data-translate="transferRights">Передать права</button>
                        
                        <div class="loading" id="transferLoading">
                            <div class="spinner"></div>
                            <p data-translate="transferInProgress">Передача прав в процессе...</p>
                        </div>
                        
                        <div class="result" id="transferResult"></div>
                    </div>
                </div>

                <div class="tab-content owner-section" id="ownerTab">
                    <div class="section">
                        <h3>👑 <span data-translate="ownerPanel">Панель владельца контракта</span></h3>
                        
                        <div class="owner-stats">
                            <div class="stat-card">
                                <div class="stat-value" id="ownerContractBalance">0 ETH</div>
                                <div class="stat-label" data-translate="contractBalance">Баланс контракта</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerWalletBalance">0 ETH</div>
                                <div class="stat-label" data-translate="walletBalance">Баланс кошелька</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerRegistrationFee">0 ETH</div>
                                <div class="stat-label" data-translate="registrationTariff">Тариф регистрации</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerCommitFee">0 ETH</div>
                                <div class="stat-label" data-translate="commitTariff">Тариф коммита</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerRevealFee">0 ETH</div>
                                <div class="stat-label" data-translate="revealTariff">Тариф ревеала</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerVerificationFee">0 ETH</div>
                                <div class="stat-label" data-translate="verificationTariff">Тариф проверки</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerTransferFee">0 ETH</div>
                                <div class="stat-label" data-translate="transferTariff">Тариф передачи</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerRevealDelay">0</div>
                                <div class="stat-label" data-translate="revealDelay">Задержка Reveal (блоки)</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerTotalRegistered">0</div>
                                <div class="stat-label" data-translate="totalRegistrations">Всего регистраций</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerTotalVerifications">0</div>
                                <div class="stat-label" data-translate="totalVerifications">Всего проверок</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="ownerTotalTransfers">0</div>
                                <div class="stat-label" data-translate="totalTransfers">Всего передач</div>
                            </div>
                        </div>

                        <div class="control-card">
                            <h4>⚙️ <span data-translate="registrationModeManagement">Управление режимами регистрации</span></h4>
                            <div class="current-mode">
                                <strong data-translate="currentMode">Текущий режим:</strong> <span class="mode-status" id="currentModeStatus">-</span>
                            </div>
                            <div class="registration-mode-controls">
                                <div class="mode-buttons">
                                    <div class="mode-btn" data-mode="0"><strong data-translate="bothRegistrations">ОБЕ РЕГИСТРАЦИИ</strong><br><small data-translate="bothRegistrationsDesc">Базовая + Commit-Reveal</small></div>
                                    <div class="mode-btn" data-mode="1"><strong data-translate="onlyBasic">ТОЛЬКО БАЗОВАЯ</strong><br><small data-translate="onlyBasicDesc">Только мгновенная регистрация</small></div>
                                    <div class="mode-btn" data-mode="2"><strong data-translate="onlyCommitReveal">ТОЛЬКО COMMIT-REVEAL</strong><br><small data-translate="onlyCommitRevealDesc">Только защищенная регистрация</small></div>
                                    <div class="mode-btn" data-mode="3"><strong data-translate="allDisabled">ВСЕ ОТКЛЮЧЕНО</strong><br><small data-translate="allDisabledDesc">Регистрации временно недоступны</small></div>
                                </div>
                            </div>
                            <div class="loading" id="modeLoading" style="display: none;">
                                <div class="spinner"></div>
                                <p data-translate="updatingMode">Обновление режима...</p>
                            </div>
                            <div class="result" id="modeResult"></div>
                        </div>

                        <div class="owner-controls">
                            <div class="control-card">
                                <h4>💳 <span data-translate="balanceManagement">Управление балансом</span></h4>
                                <div class="input-group">
                                    <label data-translate="amountToWithdraw">Сумма для вывода (в wei):</label>
                                    <input type="text" id="withdrawAmount" placeholder="" 
                                           style="font-family: monospace;" autocomplete="off">
                                </div>
                                <button class="btn btn-danger" id="withdrawFees" style="width: 100%;" data-translate="withdrawFunds">Вывести средства с контракта</button>
                                <div class="loading" id="withdrawLoading">
                                    <div class="spinner"></div>
                                    <p data-translate="withdrawInProgress">Вывод средств...</p>
                                </div>
                                <div class="result" id="withdrawResult"></div>
                            </div>

                           <div class="control-card">
    <h4>⚙️ <span data-translate="tariffsAndDelaysManagement">Управление тарифами и задержками</span></h4>
    <div class="input-group">
        <label data-translate="newBasicFee">Базовая регистрация:</label>
        <input type="text" class="fee-input" id="newRegistrationFee" placeholder="0" autocomplete="off">
        <span class="fee-currency" id="basicFeeCurrency">ETH</span>
        <button class="clear-input" id="clearRegistrationFee" title="Очистить поле">✕</button>
    </div>
    <div class="input-group">
        <label data-translate="newCommitFee">Коммит регистрация:</label>
        <input type="text" class="fee-input" id="newCommitFee" placeholder="0" autocomplete="off">
        <span class="fee-currency" id="commitFeeCurrency">ETH</span>
        <button class="clear-input" id="clearCommitFee" title="Очистить поле">✕</button>
    </div>
    <div class="input-group">
        <label data-translate="newRevealFee">Ревеал регистрация:</label>
        <input type="text" class="fee-input" id="newRevealFee" placeholder="0" autocomplete="off">
        <span class="fee-currency" id="revealFeeCurrency">ETH</span>
        <button class="clear-input" id="clearRevealFee" title="Очистить поле">✕</button>
    </div>
    <div class="input-group">
        <label data-translate="newVerificationFee">Проверка регистрации:</label>
        <input type="text" class="fee-input" id="newVerificationFee" placeholder="0" autocomplete="off">
        <span class="fee-currency" id="verificationFeeCurrency">ETH</span>
        <button class="clear-input" id="clearVerificationFee" title="Очистить поле">✕</button>
    </div>
    <div class="input-group">
        <label data-translate="newTransferFee">Передача прав:</label>
        <input type="text" class="fee-input" id="newTransferFee" placeholder="0" autocomplete="off">
        <span class="fee-currency" id="transferFeeCurrency">ETH</span>
        <button class="clear-input" id="clearTransferFee" title="Очистить поле">✕</button>
    </div>
    <div class="input-group">
        <label data-translate="newRevealDelay">Задержка Reveal (блоки):</label>
        <input type="number" class="fee-input" id="newRevealDelay" placeholder="0" step="1" min="1" autocomplete="off">
        <span class="fee-currency" id="delayCurrency">блоков</span>
        <button class="clear-input" id="clearRevealDelay" title="Очистить поле">✕</button>
    </div>
    <button class="btn btn-info" id="updateAllFees" style="width: 100%; margin-top: 10px;" data-translate="updateAllTariffs">Обновить все тарифы и задержку</button>
    <div class="loading" id="updateFeesLoading">
        <div class="spinner"></div>
        <p data-translate="updatingTariffs">Обновление тарифов...</p>
    </div>
    <div class="result" id="updateFeesResult"></div>
</div>

                            <div class="control-card">
                                <h4>🛑 <span data-translate="contractManagement">Управление контрактом</span></h4>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-warning" id="stopContract" style="flex: 1;" data-translate="stopContract">Остановить контракт</button>
                                    <button class="btn btn-success" id="activateContract" style="flex: 1;" data-translate="activateContract">Активировать контракт</button>
                                </div>
                                <div class="result" id="contractStateResult"></div>
                            </div>

                            <!-- НОВАЯ СЕКЦИЯ: Передача владения контрактом -->
                            <div class="control-card">
                                <h4>👑 <span data-translate="contractOwnershipTransfer">Передача владения контрактом</span></h4>
                                <div class="security-warning">
                                    <h5>⚠️ <span data-translate="criticalOperation">КРИТИЧЕСКАЯ ОПЕРАЦИЯ</span></h5>
                                    <p data-translate="contractTransferWarning">После передачи владения вы потеряете все права управления контрактом. Операция необратима!</p>
                                </div>
                                <div class="input-group">
                                    <label data-translate="newOwnerAddress">Адрес нового владельца:</label>
                                    <input type="text" id="newContractOwnerAddress" placeholder="0x..." 
                                           style="font-family: monospace;" autocomplete="off"
                                           pattern="^0x[a-fA-F0-9]{40}$">
                                    <button class="clear-input" id="clearNewContractOwner" title="" data-translate="clearField">✕</button>
                                    <div class="input-hint" id="newContractOwnerAddressHint">
                                        ⚠️ <span data-translate="doNotEnterManually">Не вводите вручную, используйте копирование и вставку</span>
                                    </div>
                                    <div class="validation-message" id="newContractOwnerAddressValidation"></div>
                                </div>
                                <button class="btn btn-danger" id="transferContractOwnership" style="width: 100%;" disabled data-translate="transferContractOwnership">Передать владение контрактом</button>
                                <div class="loading" id="transferContractLoading">
                                    <div class="spinner"></div>
                                    <p data-translate="ownershipTransferInProgress">Передача владения...</p>
                                </div>
                                <div class="result" id="transferContractResult"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        
       // Конфигурация сетей - добавляем RPC провайдеры и шлюзы покупки
        const NETWORKS = {
            11155111: {
                name: 'Sepolia Testnet',
                chainId: '0xaa36a7',
                currency: 'ETH',
                contractAddress: '0x42D5fC334F7938F3f2a2d53cB3AE5608B543a5ba',
                enabled: true,
                explorer: 'https://sepolia.etherscan.io',
                rpcUrl: 'https://sepolia.infura.io/v3/',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=ETH&apiKey=pk_test_123',
                gasLimits: {
                    COMMIT: 220000,
                    REVEAL: 300000, 
                    BASIC: 270000,
                    VERIFY: 210000,
                    TRANSFER: 210000
                }
            },
            1: {
                name: 'Ethereum Mainnet',
                chainId: '0x1',
                currency: 'ETH',
                contractAddress: '',
                enabled: true,
                explorer: 'https://etherscan.io',
                rpcUrl: 'https://mainnet.infura.io/v3/',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=ETH',
                gasLimits: {
                    COMMIT: 250000,
                    REVEAL: 350000,
                    BASIC: 300000,
                    VERIFY: 250000,
                    TRANSFER: 250000
                }
            },
            137: {
                name: 'Polygon Mainnet',
                chainId: '0x89',
                currency: 'MATIC',
                contractAddress: '',
                enabled: true,
                explorer: 'https://polygonscan.com',
                rpcUrl: 'https://polygon-rpc.com',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=MATIC',
                gasLimits: {
                    COMMIT: 250000,
                    REVEAL: 350000,
                    BASIC: 300000,
                    VERIFY: 250000,
                    TRANSFER: 250000
                }
            },
            10: {
                name: 'Optimism',
                chainId: '0xa',
                currency: 'ETH',
                contractAddress: '',
                enabled: true,
                explorer: 'https://optimistic.etherscan.io',
                rpcUrl: 'https://mainnet.optimism.io',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=ETH',
                gasLimits: {
                    COMMIT: 250000,
                    REVEAL: 350000,
                    BASIC: 300000,
                    VERIFY: 250000,
                    TRANSFER: 250000
                }
            },
            42161: {
                name: 'Arbitrum One',
                chainId: '0xa4b1',
                currency: 'ETH',
                contractAddress: '',
                enabled: true,
                explorer: 'https://arbiscan.io',
                rpcUrl: 'https://arb1.arbitrum.io/rpc',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=ETH',
                gasLimits: {
                    COMMIT: 250000,
                    REVEAL: 350000,
                    BASIC: 300000,
                    VERIFY: 250000,
                    TRANSFER: 250000
                }
            },
            8453: {
                name: 'Base',
                chainId: '0x2105',
                currency: 'ETH',
                contractAddress: '',
                enabled: true,
                explorer: 'https://basescan.org',
                rpcUrl: 'https://mainnet.base.org',
                buyUrl: 'https://buy.moonpay.com/?defaultCurrencyCode=ETH',
                gasLimits: {
                    COMMIT: 250000,
                    REVEAL: 350000,
                    BASIC: 300000,
                    VERIFY: 250000,
                    TRANSFER: 250000
                }
            }
        };

 // Улучшенная функция с логированием
function getGasLimit(operation) {
    let gasLimit;
    
    if (!currentNetwork || !currentNetwork.gasLimits) {
        const defaults = {
            COMMIT: 220000,
            REVEAL: 300000,
            BASIC: 270000,
            VERIFY: 210000,
            TRANSFER: 210000
        };
        gasLimit = defaults[operation] || 200000;
        console.log(`⚠️ Используется gas limit по умолчанию для ${operation}: ${gasLimit}`);
    } else {
        gasLimit = currentNetwork.gasLimits[operation] || 200000;
        console.log(`✅ Gas limit для ${operation} в сети ${currentNetwork.name}: ${gasLimit}`);
    }
    
    return gasLimit;
}

        const APP_VERSION = "5.0";
          // ==================== МНОГОЯЗЫЧНАЯ ПОДДЕРЖКА ====================

// Тексты для разных языков
const TRANSLATIONS = {
    ru: {languageSet: "Язык установлен: Русский",
        contractStoppedTitle: "⚠️ КОНТРАКТ ОСТАНОВЛЕН",
        contractStoppedMessage1: "Контракт временно приостановлен владельцем.",
        contractStoppedMessage2: "Регистрация контента временно недоступна.",
        newBasicFee: "Базовая регистрация (в wei):",
newCommitFee: "Коммит регистрация (в wei):", 
newRevealFee: "Ревеал регистрация (в wei):",
newVerificationFee: "Проверка регистрации (в wei):",
newTransferFee: "Передача прав (в wei):",
newRevealDelay: "Задержка Reveal (блоки):",

        // Заголовки и общие элементы
        appTitle: "Digital Notary DApp",
        sidebarTitle: "🔏 Digital Notary",
        contractStatus: "Статус контракта",
        connectWallet: "📱 Подключить MetaMask",
        
        // Навигация
        navAbout: "О приложении",
        navPurpose: "Для чего нужно", 
        navHowItWorks: "Как это работает",
        navAgreement: "Соглашение",
        navRegistration: "Регистрация контента",
        navVerification: "Проверка регистрации",
        navTransfer: "Передача прав",
        navOwner: "Панель владельца",
        
        // Кнопки и действия
        registerContent: "Зарегистрировать контент",
        verifyContent: "Проверить регистрацию",
        transferOwnership: "Передать права",
        
        // Сообщения
        welcomeInstruction: "Для работы Dapp необходим Metamask",
        selectLanguage: "Выберите язык интерфейса",
        
        // Сеть
        networkNotConnected: "Не подключен",
        selectNetwork: "Выберите сеть",
        switchNetwork: "🔄 Сменить сеть",
        
        // Раздел "О приложении"
        aboutApp: "О приложении",
        whatIsBlockchain: "Что такое блокчейн",
        blockchainDefinition: "Блокчейн",
        blockchainDescription: "— это распределённая база данных, где каждая запись хранится навсегда. Каждый новый блок навсегда связывается с предыдущим, и изменить прошлое невозможно без разрушения всей цепочки. Это делает блокчейн неизменяемым, надёжным и абсолютно прозрачным источником данных.",
        whyBlockchainPerfect: "Почему блокчейн — идеальное решение для цифрового нотариата",
        immutability: "Неизменность",
        immutabilityDesc: "Данные невозможно подделать или удалить",
        forever: "Навсегда",
        foreverDesc: "Запись остаётся в блокчейне навсегда, даже если приложение или сайт исчезнет",
        verifiability: "Проверяемость",
        verifiabilityDesc: "Любой человек в мире может убедиться в существовании записи, независимо от третьих лиц",
        noIntermediaries: "Отсутствие посредников",
        noIntermediariesDesc: "Всё происходит напрямую между вами и сетью блокчейна",
        whatAppDoes: "Что делает это приложение",
        appName: "Digital Notary DApp",
        appDescription: "— это децентрализованный цифровой нотариус. Вы можете зафиксировать факт владения любым вашим цифровым контентом: документом, фото, видео, песней, стихом, проектом, контрактом, изобретением и т.д. Одна минута — и право на ваш контент зафиксировано навсегда.",
        
        // Раздел "Для чего нужно"
        purposeTitle: "Для чего нужно приложение",
        whatIsUsedFor: "Для чего используется",
        purposeDescription: "нужен, чтобы доказать ваше авторство и право владения цифровым контентом. Любой контент, который вы создали, может быть закреплён в блокчейне с отметкой времени и вашим адресом. Это — ваш цифровой нотариус, работающий без людей, без нотариусов и без доверия к кому-либо.",
        examplesWhereVital: "Примеры, где это жизненно важно:",
        basicRegistration: "Базовая регистрация (одна транзакция)",
        basicRegistrationDesc: "Подходит, если вы хотите просто зафиксировать факт владения контентом:",
        basicRegistrationItem1: "тексты, статьи, заметки, публикации",
        basicRegistrationItem2: "фотографии, иллюстрации, рисунки",
        basicRegistrationItem3: "песни, музыка, стихи",
        basicRegistrationItem4: "черновики, наброски, идеи",
        basicRegistrationItem5: "деловые документы, договора, инструкции",
        basicRegistrationItem6: "завещания, письма, заявления, рецепты",
        whenToUse: "Когда использовать:",
        basicRegistrationUsage: "если контент не требует скрытия содержания (в момент регистрации в блокчейне) и может быть зафиксирован напрямую.",
        commitRevealRegistration: "Коммит–ревеал регистрация (две транзакции)",
        commitRevealDesc: "Подходит для ценных, конфиденциальных или коммерческих материалов:",
        commitRevealItem1: "патенты, изобретения, исследования",
        commitRevealItem2: "сценарии, тексты до публикации",
        commitRevealItem3: "проекты, коммерческие предложения, контракты",
        commitRevealItem4: "стратегические документы, исходные коды, AI-модели",
        advantage: "Преимущество:",
        commitRevealAdvantage: "Сначала вы фиксируете \"обещание\" (коммит), не раскрывая контент, а потом раскрываете его (ревеал). Если коммит уже Ваш в блокчейн-то ревеал гарантированно Ваш. Это гарантирует двойную защиту-никто не узнает, что именно вы регистрировали, пока вы сами не раскроете.",
        whyImportant: "Почему это важно",
        confirmsAuthorship: "Подтверждает авторство",
        confirmsAuthorshipDesc: "в любой момент времени",
        courtEvidence: "Доказательство в суде",
        courtEvidenceDesc: "может использоваться как юридическое доказательство",
        plagiarismProtection: "Защита от плагиата",
        plagiarismProtectionDesc: "и кражи контента",
        fixesDate: "Фиксирует дату",
        fixesDateDesc: "создания навсегда",
        rightsTransfer: "Передача прав",
        rightsTransferDesc: "официально и прозрачно",
        
        // Раздел "Как это работает"
        howItWorksTitle: "Как это работает",
        principle: "Принцип",
        principleDesc1: "У вас есть контент, то есть всё, что имеет цифровую форму: тексты, документы, фото, видео, музыка, контракты, завещания — всё, что уникально и принадлежит вам.",
        principleDesc2: "С помощью Digital Notary DApp вы создаёте уникальный цифровой отпечаток (хэш) этого контента, который записывается в блокчейн и навсегда закрепляется за вашим адресом. Никто не сможет изменить, удалить или оспорить это право.",
        contentRegistration: "Регистрация контента",
        registrationStep1: "Перейдите в раздел",
        registration: "Регистрация",
        registrationStep2: "Выберите метод —",
        basic: "Базовый",
        commitReveal: "Коммит–Ревеал",
        registrationStep3: "Загрузите ваш файл или документ",
        registrationStep4: "Все вычисления (хэш, коммит-хэш, соль) выполняются автоматически",
        registrationStep5: "Подтвердите транзакцию в вашем кошельке",
        registrationStep6: "После успешной регистрации получите отчёт",
        registrationStep7: "Вы можете его скопировать или скачать",
        ifReportLost: "Если вы не сохранили отчёт:",
        ifReportLostDesc: "Не страшно — вы можете всегда вычислить хэш вашего контента заново и в разделе",
        verification: "Верификация",
        commitRevealRegistration: "Коммит–Ревеал регистрация (двойная защита)",
        commitRevealStep1: "Нажмите",
        commitRegistration: "Коммит Регистрация",
        commitRevealStep2: "После подтверждения дождитесь небольшой задержки (задана владельцем)",
        commitRevealStep3: "Нажмите",
        revealRegistration: "Ревеал Регистрация",
        commitRevealStep4: "Получите отчёт с деталями транзакции",
        contentVerification: "Проверка контента (верификация)",
        verificationStep1: "Перейдите в раздел",
        verificationStep2: "Вставьте хэш контента, который хотите проверить",
        verificationStep3: "Нажмите",
        check: "Проверить",
        verificationStep4: "Если контент зарегистрирован — вы увидите подтверждение и сможете получить отчёт",
        verificationStep5: "Если не зарегистрирован — появится сообщение, что записи нет в блокчейне, и вы сможете сохранить отчёт об этом факте",
        rightsTransfer: "Передача прав на контент",
        transferStep1: "Перейдите в раздел",
        transfer: "Передача прав",
        transferStep2: "Вставьте хэш зарегистрированного контента",
        transferStep3: "Введите адрес нового владельца (адрес Ethereum-аккаунта)",
        transferStep4: "Если всё введено корректно — кнопка станет активной",
        transferStep5: "Подтвердите транзакцию",
        transferStep6: "После успешной передачи получите отчёт о передаче прав",
        attention: "Внимание:",
        transferWarning: "Контракт не позволяет передавать контент самому себе, на нулевой адрес или на контрактные адреса. Ответственность за корректность введённого адреса полностью лежит на пользователе.",
        andMostImportant: "И главное",
        rightsFixedForever: "Ваше право на контент зафиксировано навсегда.",
        noOneCanChange: "Никакой администратор, нотариус или третье лицо не может это изменить или удалить.",
        yourDigitalProof: "Ваш хэш и ваш адрес в блокчейне — это ваше цифровое доказательство собственности.",
        
        // Соглашение
        userAgreement: "Пользовательское соглашение",
        agreementItem1Title: "1. Блокчейн - это технология будущего и оно уже для вас наступило",
        agreementItem1Desc: "Блокчейн представляет собой децентрализованную, распределенную и неизменяемую базу данных, которая обеспечивает прозрачность, безопасность и надежность всех операций. Используя это приложение, вы становитесь частью новой цифровой эпохи, где доверие обеспечивается технологией, а не посредниками.",
        agreementItem2Title: "2. Хэш вашего контента - это цифровой отпечаток пальцев, который для одного контента всегда одинаков",
        agreementItem2Desc: "Хэш-функция SHA-256 создает уникальный цифровой отпечаток вашего контента. Любое, даже самое незначительное изменение в контенте приведет к совершенно другому хэшу. Это гарантирует, что каждый контент имеет уникальный идентификатор, который невозможно подделать.",
        agreementItem3Title: "3. Хэш и адрес вашего аккаунта в любой сети/блокчейн - это ключи доступа к ячейке, где лежит ваша регистрация",
        agreementItem3Desc: "Хэш контента и ваш адрес Ethereum-кошелька вместе формируют уникальную пару, которая идентифицирует ваше право собственности на контент в блокчейне. Без этих данных невозможно доказать или проверить ваши права.",
        agreementItem4Title: "4. Зарегистрированное право неоспоримо и неизменимо никогда",
        agreementItem4Desc: "После регистрации контента в блокчейне запись становится неизменной и вечной. Никто, включая разработчиков приложения или владельцев контракта, не может изменить или удалить вашу регистрацию. Это обеспечивает абсолютную защиту ваших прав.",
        agreementItem5Title: "5. Храните сид-фразы от аккаунтов кошельков в недоступных местах и никогда не фотографируйте и не пересылайте",
        agreementItem5Desc: "Сид-фраза (seed phrase) - это единственный способ восстановить доступ к вашему кошельку. Потеря сид-фразы означает безвозвратную потерю доступа ко всем зарегистрированным правам и средствам. Никогда не храните сид-фразу в цифровом виде и не передавайте ее третьим лицам.",
        agreementItem6Title: "6. Никогда не вводите вручную адреса, только копируйте и вставляйте",
        agreementItem6Desc: "Ошибка даже в одном символе адреса Ethereum может привести к безвозвратной потере прав или средств. Всегда используйте функцию копирования и вставки для работы с адресами и хэшами.",
        agreementItem7Title: "7. Операции передачи права на контент необратимы, всегда проверяйте корректность адреса получателя права",
        agreementItem7Desc: "После подтверждения транзакции передачи прав операция становится необратимой. Тщательно проверяйте адрес получателя перед подтверждением операции.",
        agreementItem8Title: "8. Всегда используйте для особо ценного контента метод коммит-ревеал, он предотвращает кражу права на контент при регистрации на моменте когда транзакция в мемпуле и ждет обработки",
        agreementItem8Desc: "Метод Commit-Reveal обеспечивает дополнительную защиту от front-running атак, когда злоумышленники могут попытаться перехватить вашу транзакцию в мемпуле и зарегистрировать контент на свой адрес.",
        agreementItem9Title: "9. Внимательно изучите разделы меню \"О приложении\", \"Для чего нужно\" и \"Как это работает\"",
        agreementItem9Desc: "Перед использованием приложения настоятельно рекомендуется внимательно изучить все информационные разделы, чтобы полностью понимать принципы работы и возможные риски.",
        agreeCheckboxLabel: "Я подтверждаю, что внимательно прочитал(а) и полностью понимаю все положения данного соглашения, и соглашаюсь с ними",
        acceptAgreement: "Принять соглашение",
        
        // Регистрация контента
        contentRegistration: "Регистрация контента",
        basicRegistration: "Базовая регистрация",
        basicRegistrationDescShort: "Мгновенная регистрация контента в блокчейне",
        commitReveal: "Commit-Reveal",
        commitRevealDescShort: "Максимальная защита от front-running атак",
        fee: "Комиссия: -",
        commitRevealProcess: "Процесс Commit-Reveal",
        commitPhase: "Фаза Commit: Ожидание подтверждения транзакции",
        revealDelayWait: "Ожидание задержки reveal:",
        blocks: "блоков",
        waitingReveal: "Ожидание Reveal",
        blocksUntilReveal: "блоков до возможности раскрытия",
        commitInfo: "Информация о коммите",
        important: "ВАЖНО:",
        secureHashStorage: "Безопасное хранение хэша",
        hashIsFingerprint: "Хэш - это цифровой отпечаток вашего файла. Сохраните его в надежном месте.",
        dragFileHere: "📎 Перетащите файл сюда или нажмите для выбора",
        supportedFiles: "Поддерживаются любые файлы: документы, изображения, видео и т.д.",
        selectedFile: "Выбран файл:",
        size: "Размер:",
        type: "Тип:",
        contentHash: "Хэш контента (SHA-256):",
        hashWillBeCalculated: "Хэш будет вычислен автоматически после выбора файла",
        showHash: "Показать хэш",
        copyHash: "Копировать хэш",
        salt: "Соль (случайное значение):",
        saltWillBeGenerated: "Соль будет сгенерирована автоматически",
        commitHash: "Хэш коммита:",
        commitHashWillBeCalculated: "Хэш коммита будет вычислен автоматически",
        registerContent: "Зарегистрировать контент",
        revealContent: "Раскрыть контент (Reveal)",
        registrationInProgress: "Регистрация в процессе...",
        
        // Проверка регистрации
        registrationVerification: "Проверка регистрации",
        verificationFee: "Комиссия за проверку:",
        enterHashForVerification: "Введите хэш для проверки:",
        clearField: "Очистить поле",
        doNotEnterManually: "Не вводите вручную, используйте копирование и вставку",
        verifyRegistration: "Проверить регистрацию",
        verificationInProgress: "Проверка в процессе...",
        
        // Передача прав
        rightsTransfer: "Передача прав на контент",
        transferFee: "Комиссия за передачу прав:",
        transferWarning1: "После передачи прав вы теряете все права на контент",
        transferWarning2: "Операция необратима и записывается в блокчейн",
        transferWarning3: "Нельзя передавать права самому себе",
        contentHashYouOwn: "Хэш контента (которым вы владеете):",
        newOwnerAddress: "Адрес нового владельца:",
        transferRights: "Передать права",
        transferInProgress: "Передача прав в процессе...",
        
        // Панель владельца
        ownerPanel: "Панель владельца контракта",
        contractBalance: "Баланс контракта",
        walletBalance: "Баланс кошелька",
        registrationTariff: "Тариф регистрации",
        commitTariff: "Тариф коммита",
        revealTariff: "Тариф ревеала",
        verificationTariff: "Тариф проверки",
        transferTariff: "Тариф передачи",
        revealDelay: "Задержка Reveal (блоки)",
        totalRegistrations: "Всего регистраций",
        totalVerifications: "Всего проверок",
        totalTransfers: "Всего передач",
        registrationModeManagement: "Управление режимами регистрации",
        currentMode: "Текущий режим:",
        bothRegistrations: "ОБЕ РЕГИСТРАЦИИ",
        bothRegistrationsDesc: "Базовая + Commit-Reveal",
        onlyBasic: "ТОЛЬКО БАЗОВАЯ",
        onlyBasicDesc: "Только мгновенная регистрация",
        onlyCommitReveal: "ТОЛЬКО COMMIT-REVEAL",
        onlyCommitRevealDesc: "Только защищенная регистрация",
        allDisabled: "ВСЕ ОТКЛЮЧЕНО",
        allDisabledDesc: "Регистрации временно недоступны",
        updatingMode: "Обновление режима...",
        balanceManagement: "Управление балансом",
        amountToWithdraw: "Сумма для вывода (в wei):",
        withdrawFunds: "Вывести средства с контракта",
        withdrawInProgress: "Вывод средств...",
        tariffsAndDelaysManagement: "Управление тарифами и задержками",
        updateAllTariffs: "Обновить все тарифы и задержку",
        updatingTariffs: "Обновление тарифов...",
        contractManagement: "Управление контрактом",
        stopContract: "Остановить контракт",
        activateContract: "Активировать контракт",
        contractOwnershipTransfer: "Передача владения контрактом",
        criticalOperation: "КРИТИЧЕСКАЯ ОПЕРАЦИЯ",
        contractTransferWarning: "После передачи владения вы потеряете все права управления контрактом. Операция необратима!",
        transferContractOwnership: "Передать владение контрактом",
        ownershipTransferInProgress: "Передача владения...",
        
        // Контакт разработчика
        developerContact: "owner",
        
        // Welcome
        welcomeSubtitle: "Децентрализованный цифровой нотариус",
        contractStatusActive: "АКТИВНО",
        contractStatusInactive: "ОСТАНОВЛЕН",
        contractStatusUnknown: "НЕ ИЗВЕСТНО",
        metamaskConnected: "✅ MetaMask подключен"
    },
    en: {languageSet: "Language set: English",
        contractStoppedTitle: "⚠️ CONTRACT STOPPED", 
        contractStoppedMessage1: "Contract temporarily suspended by owner.",
        contractStoppedMessage2: "Content registration is temporarily unavailable.",
        newBasicFee: "Basic registration (in wei):",
newCommitFee: "Commit registration (in wei):",
newRevealFee: "Reveal registration (in wei):", 
newVerificationFee: "Registration verification (in wei):",
newTransferFee: "Rights transfer (in wei):",
newRevealDelay: "Reveal delay (blocks):",

        // Заголовки и общие элементы
        appTitle: "Digital Notary DApp",
        sidebarTitle: "🔏 Digital Notary",
        contractStatus: "Contract Status",
        connectWallet: "📱 Connect MetaMask",
        
        // Навигация
        navAbout: "About",
        navPurpose: "Purpose", 
        navHowItWorks: "How It Works",
        navAgreement: "Agreement",
        navRegistration: "Content Registration",
        navVerification: "Verification",
        navTransfer: "Transfer Rights",
        navOwner: "Owner Panel",
        
        // Кнопки и действия
        registerContent: "Register Content",
        verifyContent: "Verify Registration", 
        transferOwnership: "Transfer Ownership",
        
        // Сообщения
        welcomeInstruction: "MetaMask is required to use dapps",
        selectLanguage: "Select interface language",
        
        // Сеть
        networkNotConnected: "Not connected",
        selectNetwork: "Select network",
        switchNetwork: "🔄 Switch Network",
        
        // Раздел "О приложении"
        aboutApp: "About Application",
        whatIsBlockchain: "What is Blockchain",
        blockchainDefinition: "Blockchain",
        blockchainDescription: "is a distributed database where every record is stored forever. Each new block is permanently linked to the previous one, and it's impossible to change the past without destroying the entire chain. This makes blockchain immutable, reliable, and an absolutely transparent source of data.",
        whyBlockchainPerfect: "Why Blockchain is the Perfect Solution for Digital Notary",
        immutability: "Immutability",
        immutabilityDesc: "Data cannot be forged or deleted",
        forever: "Forever",
        foreverDesc: "The record remains in the blockchain forever, even if the application or website disappears",
        verifiability: "Verifiability",
        verifiabilityDesc: "Anyone in the world can verify the existence of the record, independently of third parties",
        noIntermediaries: "No Intermediaries",
        noIntermediariesDesc: "Everything happens directly between you and the blockchain network",
        whatAppDoes: "What This Application Does",
        appName: "Digital Notary DApp",
        appDescription: "is a decentralized digital notary. You can record ownership of any of your digital content: documents, photos, videos, songs, poems, projects, contracts, inventions, etc. One minute - and your content rights are recorded forever.",
        
        // Раздел "Для чего нужно"
        purposeTitle: "What the Application is For",
        whatIsUsedFor: "What It's Used For",
        purposeDescription: "is needed to prove your authorship and ownership of digital content. Any content you've created can be recorded in the blockchain with a timestamp and your address. This is your digital notary, working without people, without notaries, and without trust in anyone.",
        examplesWhereVital: "Examples Where This is Vital:",
        basicRegistration: "Basic Registration (one transaction)",
        basicRegistrationDesc: "Suitable if you simply want to record ownership of content:",
        basicRegistrationItem1: "texts, articles, notes, publications",
        basicRegistrationItem2: "photos, illustrations, drawings",
        basicRegistrationItem3: "songs, music, poems",
        basicRegistrationItem4: "drafts, sketches, ideas",
        basicRegistrationItem5: "business documents, contracts, instructions",
        basicRegistrationItem6: "wills, letters, statements, recipes",
        whenToUse: "When to Use:",
        basicRegistrationUsage: "if the content doesn't require hiding its content (at the moment of registration in the blockchain) and can be recorded directly.",
        commitRevealRegistration: "Commit-Reveal Registration (two transactions)",
        commitRevealDesc: "Suitable for valuable, confidential, or commercial materials:",
        commitRevealItem1: "patents, inventions, research",
        commitRevealItem2: "scripts, texts before publication",
        commitRevealItem3: "projects, commercial proposals, contracts",
        commitRevealItem4: "strategic documents, source codes, AI models",
        advantage: "Advantage:",
        commitRevealAdvantage: "First you record a 'promise' (commit) without revealing the content, and then you reveal it (reveal). If the commit is already yours in the blockchain, then the reveal is guaranteed to be yours. This guarantees double protection - no one will know what exactly you registered until you reveal it yourself.",
        whyImportant: "Why This is Important",
        confirmsAuthorship: "Confirms Authorship",
        confirmsAuthorshipDesc: "at any moment in time",
        courtEvidence: "Court Evidence",
        courtEvidenceDesc: "can be used as legal evidence",
        plagiarismProtection: "Plagiarism Protection",
        plagiarismProtectionDesc: "and content theft",
        fixesDate: "Fixes Date",
        fixesDateDesc: "of creation forever",
        rightsTransfer: "Rights Transfer",
        rightsTransferDesc: "officially and transparently",
        
        // Раздел "Как это работает"
        howItWorksTitle: "How It Works",
        principle: "Principle",
        principleDesc1: "You have content, that is, everything that has a digital form: texts, documents, photos, videos, music, contracts, wills - everything that is unique and belongs to you.",
        principleDesc2: "With Digital Notary DApp, you create a unique digital fingerprint (hash) of this content, which is recorded in the blockchain and permanently attached to your address. No one can change, delete, or challenge this right.",
        contentRegistration: "Content Registration",
        registrationStep1: "Go to the section",
        registration: "Registration",
        registrationStep2: "Choose method -",
        basic: "Basic",
        commitReveal: "Commit-Reveal",
        registrationStep3: "Upload your file or document",
        registrationStep4: "All calculations (hash, commit-hash, salt) are performed automatically",
        registrationStep5: "Confirm the transaction in your wallet",
        registrationStep6: "After successful registration, get a report",
        registrationStep7: "You can copy it or download it",
        ifReportLost: "If you didn't save the report:",
        ifReportLostDesc: "No problem - you can always recalculate the hash of your content and get a new report in the",
        verification: "Verification",
        commitRevealRegistration: "Commit-Reveal Registration (double protection)",
        commitRevealStep1: "Click",
        commitRegistration: "Commit Registration",
        commitRevealStep2: "After confirmation, wait for a short delay (set by the owner)",
        commitRevealStep3: "Click",
        revealRegistration: "Reveal Registration",
        commitRevealStep4: "Get a report with transaction details",
        contentVerification: "Content Verification",
        verificationStep1: "Go to the section",
        verificationStep2: "Paste the content hash you want to verify",
        verificationStep3: "Click",
        check: "Check",
        verificationStep4: "If the content is registered - you'll see confirmation and can get a report",
        verificationStep5: "If not registered - a message will appear that the record is not in the blockchain, and you can save a report about this fact",
        rightsTransfer: "Content Rights Transfer",
        transferStep1: "Go to the section",
        transfer: "Transfer Rights",
        transferStep2: "Paste the hash of registered content",
        transferStep3: "Enter the address of the new owner (Ethereum account address)",
        transferStep4: "If everything is entered correctly - the button will become active",
        transferStep5: "Confirm the transaction",
        transferStep6: "After successful transfer, get a transfer rights report",
        attention: "Attention:",
        transferWarning: "The contract doesn't allow transferring content to yourself, to a zero address, or to contract addresses. Responsibility for the correctness of the entered address lies entirely with the user.",
        andMostImportant: "And Most Importantly",
        rightsFixedForever: "Your right to content is fixed forever.",
        noOneCanChange: "No administrator, notary, or third party can change or delete this.",
        yourDigitalProof: "Your hash and your address in the blockchain are your digital proof of ownership.",
        
        // Соглашение
        userAgreement: "User Agreement",
        agreementItem1Title: "1. Blockchain is the technology of the future and it has already arrived for you",
        agreementItem1Desc: "Blockchain is a decentralized, distributed, and immutable database that provides transparency, security, and reliability for all operations. By using this application, you become part of a new digital era where trust is provided by technology, not intermediaries.",
        agreementItem2Title: "2. Your content hash is a digital fingerprint that is always the same for one content",
        agreementItem2Desc: "The SHA-256 hash function creates a unique digital fingerprint of your content. Any, even the slightest change in the content will result in a completely different hash. This ensures that each content has a unique identifier that cannot be forged.",
        agreementItem3Title: "3. The hash and your account address in any network/blockchain are the access keys to the cell where your registration is stored",
        agreementItem3Desc: "The content hash and your Ethereum wallet address together form a unique pair that identifies your ownership of the content in the blockchain. Without this data, it's impossible to prove or verify your rights.",
        agreementItem4Title: "4. The registered right is indisputable and unchangeable forever",
        agreementItem4Desc: "After registering content in the blockchain, the record becomes immutable and eternal. No one, including the application developers or contract owners, can change or delete your registration. This provides absolute protection of your rights.",
        agreementItem5Title: "5. Store wallet account seed phrases in inaccessible places and never photograph or forward them",
        agreementItem5Desc: "The seed phrase is the only way to restore access to your wallet. Losing the seed phrase means irrevocable loss of access to all registered rights and funds. Never store the seed phrase digitally or transfer it to third parties.",
        agreementItem6Title: "6. Never enter addresses manually, only copy and paste",
        agreementItem6Desc: "An error in even one character of an Ethereum address can lead to irrevocable loss of rights or funds. Always use the copy and paste function when working with addresses and hashes.",
        agreementItem7Title: "7. Content rights transfer operations are irreversible, always check the correctness of the recipient's address",
        agreementItem7Desc: "After confirming the rights transfer transaction, the operation becomes irreversible. Thoroughly check the recipient's address before confirming the operation.",
        agreementItem8Title: "8. Always use the commit-reveal method for particularly valuable content, it prevents theft of content rights during registration when the transaction is in the mempool and waiting for processing",
        agreementItem8Desc: "The Commit-Reveal method provides additional protection against front-running attacks when attackers may try to intercept your transaction in the mempool and register the content to their address.",
        agreementItem9Title: "9. Carefully study the menu sections \"About\", \"Purpose\" and \"How It Works\"",
        agreementItem9Desc: "Before using the application, it is strongly recommended to carefully study all information sections to fully understand the principles of operation and possible risks.",
        agreeCheckboxLabel: "I confirm that I have carefully read and fully understand all provisions of this agreement, and I agree with them",
        acceptAgreement: "Accept Agreement",
        
        // Регистрация контента
        contentRegistration: "Content Registration",
        basicRegistration: "Basic Registration",
        basicRegistrationDescShort: "Instant content registration in blockchain",
        commitReveal: "Commit-Reveal",
        commitRevealDescShort: "Maximum protection against front-running attacks",
        fee: "Fee: -",
        commitRevealProcess: "Commit-Reveal Process",
        commitPhase: "Commit Phase: Waiting for transaction confirmation",
        revealDelayWait: "Waiting for reveal delay:",
        blocks: "blocks",
        waitingReveal: "Waiting for Reveal",
        blocksUntilReveal: "blocks until reveal possibility",
        commitInfo: "Commit Information",
        important: "IMPORTANT:",
        secureHashStorage: "Secure Hash Storage",
        hashIsFingerprint: "Hash is the digital fingerprint of your file. Save it in a secure place.",
        dragFileHere: "📎 Drag file here or click to select",
        supportedFiles: "All file types supported: documents, images, videos, etc.",
        selectedFile: "Selected file:",
        size: "Size:",
        type: "Type:",
        contentHash: "Content Hash (SHA-256):",
        hashWillBeCalculated: "Hash will be calculated automatically after file selection",
        showHash: "Show Hash",
        copyHash: "Copy Hash",
        salt: "Salt (random value):",
        saltWillBeGenerated: "Salt will be generated automatically",
        commitHash: "Commit Hash:",
        commitHashWillBeCalculated: "Commit hash will be calculated automatically",
        registerContent: "Register Content",
        revealContent: "Reveal Content",
        registrationInProgress: "Registration in progress...",
        
        // Проверка регистрации
        registrationVerification: "Registration Verification",
        verificationFee: "Verification fee:",
        enterHashForVerification: "Enter hash for verification:",
        clearField: "Clear field",
        doNotEnterManually: "Do not enter manually, use copy and paste",
        verifyRegistration: "Verify Registration",
        verificationInProgress: "Verification in progress...",
        
        // Передача прав
        rightsTransfer: "Content Rights Transfer",
        transferFee: "Transfer fee:",
        transferWarning1: "After transferring rights, you lose all rights to the content",
        transferWarning2: "The operation is irreversible and recorded in the blockchain",
        transferWarning3: "Cannot transfer rights to yourself",
        contentHashYouOwn: "Content Hash (that you own):",
        newOwnerAddress: "New Owner Address:",
        transferRights: "Transfer Rights",
        transferInProgress: "Transfer in progress...",
        
        // Панель владельца
        ownerPanel: "Contract Owner Panel",
        contractBalance: "Contract Balance",
        walletBalance: "Wallet Balance",
        registrationTariff: "Registration Tariff",
        commitTariff: "Commit Tariff",
        revealTariff: "Reveal Tariff",
        verificationTariff: "Verification Tariff",
        transferTariff: "Transfer Tariff",
        revealDelay: "Reveal Delay (blocks)",
        totalRegistrations: "Total Registrations",
        totalVerifications: "Total Verifications",
        totalTransfers: "Total Transfers",
        registrationModeManagement: "Registration Mode Management",
        currentMode: "Current Mode:",
        bothRegistrations: "BOTH REGISTRATIONS",
        bothRegistrationsDesc: "Basic + Commit-Reveal",
        onlyBasic: "ONLY BASIC",
        onlyBasicDesc: "Only instant registration",
        onlyCommitReveal: "ONLY COMMIT-REVEAL",
        onlyCommitRevealDesc: "Only protected registration",
        allDisabled: "ALL DISABLED",
        allDisabledDesc: "Registrations temporarily unavailable",
        updatingMode: "Updating mode...",
        balanceManagement: "Balance Management",
        amountToWithdraw: "Amount to withdraw (in wei):",
        withdrawFunds: "Withdraw funds from contract",
        withdrawInProgress: "Withdrawing funds...",
        tariffsAndDelaysManagement: "Tariffs and Delays Management",
        updateAllTariffs: "Update all tariffs and delay",
        updatingTariffs: "Updating tariffs...",
        contractManagement: "Contract Management",
        stopContract: "Stop Contract",
        activateContract: "Activate Contract",
        contractOwnershipTransfer: "Contract Ownership Transfer",
        criticalOperation: "CRITICAL OPERATION",
        contractTransferWarning: "After transferring ownership, you will lose all contract management rights. The operation is irreversible!",
        transferContractOwnership: "Transfer Contract Ownership",
        ownershipTransferInProgress: "Ownership transfer in progress...",
        
        // Контакт разработчика
        developerContact: "owner",
        
        // Welcome
        welcomeSubtitle: "Decentralized Digital Notary",
        contractStatusActive: "ACTIVE",
        contractStatusInactive: "STOPPED",
        contractStatusUnknown: "UNKNOWN",
        metamaskConnected: "✅ MetaMask Connected"
    }
};

let currentLanguage = 'ru';

     // Функция выбора языка
function selectLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('preferredLanguage', lang);
    
    // Скрываем языковую панель
    document.getElementById('languageSelector').style.display = 'none';
    
    // Применяем переводы
    applyTranslations();
    
    // Показываем основное приложение
    document.querySelector('.app-container').style.display = 'flex';
    
    showNotification(getTranslation('languageSet'), 'success');
}
// Применение переводов
    function applyTranslations() {
    const texts = TRANSLATIONS[currentLanguage];
    
    // СОХРАНИМ текущий статус перед применением переводов
    const statusElement = document.getElementById('contractStatus');
    const currentStatus = statusElement.textContent;
    const currentStatusClass = statusElement.className;
    
    // Обновляем все элементы с атрибутом data-translate
    document.querySelectorAll('[data-translate]').forEach(element => {
        const key = element.getAttribute('data-translate');
        if (texts[key]) {
            // НЕ обновляем статус контракта - он устанавливается отдельно
            if (element.id === 'contractStatus') {
                return;
            }
            
            element.textContent = texts[key];
            
            // Обновляем placeholder для input полей
            if (element.tagName === 'INPUT') {
                element.placeholder = texts[key];
            }
            
            // Обновляем title для кнопок
            if (element.tagName === 'BUTTON' && element.hasAttribute('title')) {
                element.title = texts[key];
            }
        }
    });
    
    // Обновляем placeholder для специфических полей
    const verifyHashInput = document.getElementById('verifyHash');
    const transferHashInput = document.getElementById('transferHash');
    
    if (verifyHashInput) {
        verifyHashInput.placeholder = currentLanguage === 'ru' 
            ? "Вставьте SHA-256 хэш сюда (64 символа)" 
            : "Paste SHA-256 hash here (64 characters)";
    }
    
    if (transferHashInput) {
        transferHashInput.placeholder = currentLanguage === 'ru'
            ? "Введите SHA-256 хэш (64 символа)"
            : "Enter SHA-256 hash (64 characters)";
    }
    
    // ОБНОВИТЬ placeholder для полей тарифов
    const feeInputs = [
        'newRegistrationFee', 'newCommitFee', 'newRevealFee', 
        'newVerificationFee', 'newTransferFee', 'newRevealDelay'
    ];
    
    feeInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.placeholder = currentLanguage === 'ru' ? '0' : '0';
        }
    });
    
    // Обновляем welcome инструкцию
    document.getElementById('welcomeInstruction').textContent = texts.welcomeInstruction;
}

// Функция для обновления валюты в полях тарифов
async function updateFeeCurrencies() {
    if (!currentNetwork) return;
    
    const currency = currentNetwork.currency;
    document.getElementById('basicFeeCurrency').textContent = currency;
    document.getElementById('commitFeeCurrency').textContent = currency;
    document.getElementById('revealFeeCurrency').textContent = currency;
    document.getElementById('verificationFeeCurrency').textContent = currency;
    document.getElementById('transferFeeCurrency').textContent = currency;
}

// Получение переводов
function getTranslation(key) {
    const translation = TRANSLATIONS[currentLanguage][key];
    console.log(`getTranslation: key="${key}", language="${currentLanguage}", result="${translation}"`);
    return translation || key;
}

    // Проверка сохраненного языка при загрузке
function checkSavedLanguage() {
    const savedLanguage = localStorage.getItem('preferredLanguage');
    if (savedLanguage && (savedLanguage === 'ru' || savedLanguage === 'en')) {
        currentLanguage = savedLanguage;
        // УБИРАЕМ эти строки, чтобы всегда показывать языковую панель
        // document.getElementById('languageSelector').style.display = 'none';
        // document.querySelector('.app-container').style.display = 'flex';
        applyTranslations();
    }
    // ВСЕГДА показываем языковую панель при первой загрузке
    document.getElementById('languageSelector').style.display = 'flex';
    document.querySelector('.app-container').style.display = 'none';
}

        // ABI контракта 
        const CONTRACT_ABI = [
	{
		"inputs": [],
		"name": "activateContract",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_basicRegistrationFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_commitFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_revealFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_verificationFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_transferFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_revealDelay",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [],
		"name": "BasicRegistrationDisabled",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "CommitNotFound",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "CommitRegistrationDisabled",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "ContentAlreadyRegistered",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "ContentNotRegistered",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "ContractAddressNotAllowed",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "ContractStopped",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "InsufficientFee",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "InvalidAddress",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "InvalidHash",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "InvalidReveal",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "NoBalanceToWithdraw",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "NotContentOwner",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "NotContractOwner",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "RevealDelayNotPassed",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "commitowner",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "blockNumber",
				"type": "uint256"
			}
		],
		"name": "ContentCommitted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [],
		"name": "ContentOwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [],
		"name": "ContentRegistered",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [],
		"name": "ContentRevealed",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [],
		"name": "ContentVerified",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "oldOwner",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "ContractOwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "enum DigitalNotary.ContractState",
				"name": "newState",
				"type": "uint8"
			}
		],
		"name": "ContractStateChanged",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [],
		"name": "FeesAndDelayUpdated",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "_contentHash",
				"type": "bytes32"
			}
		],
		"name": "registerContent",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "_commitHash",
				"type": "bytes32"
			}
		],
		"name": "registerContentCommit",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "_commitHash",
				"type": "bytes32"
			},
			{
				"internalType": "bytes32",
				"name": "_contentHash",
				"type": "bytes32"
			},
			{
				"internalType": "bytes32",
				"name": "_salt",
				"type": "bytes32"
			}
		],
		"name": "registerContentReveal",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "enum DigitalNotary.RegistrationMode",
				"name": "newMode",
				"type": "uint8"
			}
		],
		"name": "RegistrationModeChanged",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "enum DigitalNotary.RegistrationMode",
				"name": "_newMode",
				"type": "uint8"
			}
		],
		"name": "setRegistrationMode",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "stopContract",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "_contentHash",
				"type": "bytes32"
			},
			{
				"internalType": "address",
				"name": "_newOwner",
				"type": "address"
			}
		],
		"name": "transferContentOwnership",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferContractOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_basicRegistrationFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_commitFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_revealFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_verificationFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_transferFee",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_revealDelay",
				"type": "uint256"
			}
		],
		"name": "updateFeesAndDelay",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "_contentHash",
				"type": "bytes32"
			}
		],
		"name": "verifyContent",
		"outputs": [
			{
				"internalType": "bool",
				"name": "exists",
				"type": "bool"
			},
			{
				"internalType": "address",
				"name": "registrant",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "originalRegistrant",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"internalType": "uint16",
				"name": "transferCount",
				"type": "uint16"
			},
			{
				"internalType": "uint64",
				"name": "lastTransferTime",
				"type": "uint64"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_amount",
				"type": "uint256"
			}
		],
		"name": "withdrawBalance",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "WithdrawnBalance",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "basicRegistrationFee",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "commitFee",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "",
				"type": "bytes32"
			}
		],
		"name": "commitInfo",
		"outputs": [
			{
				"internalType": "address",
				"name": "commitowner",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "blockNumber",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getAllFeesAndDelay",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getContractBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getContractStats",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getRegistrationMode",
		"outputs": [
			{
				"internalType": "enum DigitalNotary.RegistrationMode",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "registrationMode",
		"outputs": [
			{
				"internalType": "enum DigitalNotary.RegistrationMode",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "",
				"type": "bytes32"
			}
		],
		"name": "registrations",
		"outputs": [
			{
				"internalType": "address",
				"name": "registrant",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "originalRegistrant",
				"type": "address"
			},
			{
				"internalType": "uint64",
				"name": "timestamp",
				"type": "uint64"
			},
			{
				"internalType": "uint64",
				"name": "lastTransferTime",
				"type": "uint64"
			},
			{
				"internalType": "uint16",
				"name": "transferCount",
				"type": "uint16"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "revealDelay",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "revealFee",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "state",
		"outputs": [
			{
				"internalType": "enum DigitalNotary.ContractState",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalRegistered",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalTransfers",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalVerifications",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "transferFee",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "userToCommit",
		"outputs": [
			{
				"internalType": "bytes32",
				"name": "",
				"type": "bytes32"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "verificationFee",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];

        // Глобальные переменные
        let selectedTokenAmount = 0;
        let currentOperation = null; // 'registration', 'verification', 'transfer'
        let operationCallback = null;
        let provider;
        let signer;
        let contract;
        let currentHash = '';
        let currentSalt = '';
        let currentCommitHash = '';
        let isHashVisible = false;
        let isOwner = false;
        let ownerAddress = '';
        let currentUserAddress = '';
        let currentNetwork = null;
        let currentProtection = 'BASIC';
        let commitBlockNumber = 0;
        let revealDelay = 0;
        let commitRevealInterval = null;
        let currentRegistrationMode = 0;
        let userAgreed = false;
        let currentReport = null;
        let lastContractStatus = null;
         

        // ==================== ФУНКЦИИ ДЛЯ ПОКУПКИ ТОКЕНОВ ====================

// Функция проверки баланса и предложения покупки
async function checkBalanceAndProceed(operation, callback) {
    if (!currentNetwork || !currentUserAddress) {
        showNotification('Network or wallet not connected', 'error');
        return;
    }

    currentOperation = operation;
    operationCallback = callback;

    try {
        // Получаем текущий баланс
        const balance = await provider.getBalance(currentUserAddress);
        const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
        
        // Определяем минимальный требуемый баланс для операции
        const minRequired = await getMinRequiredBalance(operation);
        
        console.log(`Balance check: ${balanceInEth} ${currentNetwork.currency}, required: ${minRequired}`);
        
        if (balanceInEth >= minRequired) {
            // Баланса достаточно - выполняем операцию
            if (callback) callback();
        } else {
            // Баланса недостаточно - предлагаем покупку
            showBuyTokensModal(balanceInEth, minRequired);
        }
        
    } catch (error) {
        console.error('Balance check error:', error);
        showNotification('Error checking balance', 'error');
    }
}

// Получение минимального требуемого баланса для операции
async function getMinRequiredBalance(operation) {
    if (!contract) return 0.01; // Значение по умолчанию

    try {
        let fee = ethers.BigNumber.from(0);
        
        switch(operation) {
            case 'registration':
                if (currentProtection === 'BASIC') {
                    fee = await contract.basicRegistrationFee();
                } else {
                    const commitFee = await contract.commitFee();
                    const revealFee = await contract.revealFee();
                    fee = commitFee.add(revealFee);
                }
                break;
            case 'verification':
                fee = await contract.verificationFee();
                break;
            case 'transfer':
                fee = await contract.transferFee();
                break;
        }
        
        // Добавляем запас на газовые fees (примерно 0.001-0.003 ETH)
        const gasBuffer = ethers.utils.parseEther('0.003');
        const totalRequired = fee.add(gasBuffer);
        
        return parseFloat(ethers.utils.formatEther(totalRequired));
        
    } catch (error) {
        console.error('Error getting required balance:', error);
        return 0.01; // Значение по умолчанию при ошибке
    }
}

// Показ модального окна покупки токенов
async function showBuyTokensModal(currentBalance, requiredBalance) {
    const modal = document.getElementById('buyTokensModal');
    const balanceDisplay = document.getElementById('currentBalanceDisplay');
    const tokenSymbolElements = document.querySelectorAll('#tokenSymbol');
    const warningElement = document.getElementById('purchaseWarning');
    
    // Обновляем отображение баланса
    balanceDisplay.textContent = `${currentBalance.toFixed(4)} ${currentNetwork.currency}`;
    balanceDisplay.className = `balance-status ${currentBalance < requiredBalance ? 'balance-insufficient' : 'balance-sufficient'}`;
    
    // Обновляем символы валюты
    tokenSymbolElements.forEach(element => {
        element.textContent = currentNetwork.currency;
    });
    
    // Показываем предупреждение если баланс недостаточен
    if (currentBalance < requiredBalance) {
        warningElement.style.display = 'block';
        warningElement.innerHTML = `
            <strong>⚠️ Insufficient Balance:</strong> 
            You need at least ${requiredBalance.toFixed(4)} ${currentNetwork.currency} 
            for this operation. Current: ${currentBalance.toFixed(4)} ${currentNetwork.currency}
        `;
    } else {
        warningElement.style.display = 'none';
    }
    
    // Загружаем примерные цены в USD
    await loadTokenPrices();
    
    modal.style.display = 'flex';
}

// Закрытие модального окна
function closeBuyTokensModal() {
    document.getElementById('buyTokensModal').style.display = 'none';
    selectedTokenAmount = 0;
    document.querySelectorAll('.token-option').forEach(opt => opt.classList.remove('selected'));
    document.getElementById('customAmount').value = '';
}

// Выбор суммы токенов
function selectTokenAmount(amount) {
    selectedTokenAmount = amount;
    document.querySelectorAll('.token-option').forEach(opt => opt.classList.remove('selected'));
    event.target.closest('.token-option').classList.add('selected');
    document.getElementById('customAmount').value = '';
}

// Обработка кастомной суммы
function setupTokenPurchaseListeners() {
    document.getElementById('customAmount').addEventListener('input', function() {
        const customAmount = parseFloat(this.value);
        if (!isNaN(customAmount) && customAmount > 0) {
            selectedTokenAmount = customAmount;
            document.querySelectorAll('.token-option').forEach(opt => opt.classList.remove('selected'));
        }
    });
}

// Продолжение с покупкой
function proceedWithPurchase() {
    if (selectedTokenAmount <= 0) {
        showNotification('Please select token amount', 'error');
        return;
    }

    // Открываем шлюз покупки в новой вкладке
    openBuyGateway(selectedTokenAmount);
    closeBuyTokensModal();
    
    // Показываем инструкцию
    showNotification(`Redirecting to token purchase...`, 'info');
}

// Пропуск покупки
function skipPurchase() {
    closeBuyTokensModal();
    showNotification('You can purchase tokens later when needed', 'info');
}

// Открытие шлюза покупки
function openBuyGateway(amount) {
    if (!currentNetwork || !currentNetwork.buyUrl) {
        // Если нет специфичного шлюза, открываем общую страницу MoonPay
        window.open(`https://buy.moonpay.com/?defaultCurrencyCode=${currentNetwork.currency}`, '_blank');
        return;
    }

    // Формируем URL с параметрами
    const buyUrl = `${currentNetwork.buyUrl}&amount=${amount}&walletAddress=${currentUserAddress}`;
    window.open(buyUrl, '_blank');
}

    // Функция для получения текущего chainId
async function getCurrentChainId() {
    if (currentNetwork && currentNetwork.chainId) {
        // Если currentNetwork уже есть, берем chainId оттуда
        return parseInt(currentNetwork.chainId);
    }
    
    try {
        // Если currentNetwork нет, получаем из провайдера
        const network = await provider.getNetwork();
        return network.chainId;
    } catch (error) {
        console.error('Ошибка получения chainId:', error);
        return null;
    }
}     

    // Загрузка актуальных цен с Binance API
async function loadTokenPrices() {
    try {
        console.log('🔄 Получение актуальных цен с Binance...');
        
        // Соответствие символов токенов в Binance для КАЖДОЙ сети
        const networkSymbols = {
            // Ethereum сети (используют ETH)
            '1': 'ETHUSDT',      // Ethereum Mainnet
            '11155111': 'ETHUSDT', // Sepolia Testnet
            '10': 'ETHUSDT',     // Optimism
            '42161': 'ETHUSDT',  // Arbitrum
            '8453': 'ETHUSDT',   // Base
            
            // Polygon сети (используют MATIC)
            '137': 'MATICUSDT',  // Polygon Mainnet
            '80001': 'MATICUSDT', // Polygon Testnet,
        };
        
        const chainId = await getCurrentChainId();
        const symbol = networkSymbols[chainId];
        
        // Если сеть не поддерживается, используем резервные цены
        if (!symbol) {
            console.log(`❌ Сеть с chainId ${chainId} не поддерживается Binance API`);
            await useFallbackPrices();
            return;
        }
        
        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
        
        if (!response.ok) {
            throw new Error('Binance API error: ' + response.status);
        }
        
        const data = await response.json();
        const price = parseFloat(data.price);
        
        console.log(`✅ Актуальная цена для сети ${currentNetwork.name}: $${price}`);
        
        // Обновляем цены в интерфейсе
        document.getElementById('price001').textContent = (0.01 * price).toFixed(2);
        document.getElementById('price005').textContent = (0.05 * price).toFixed(2);
        document.getElementById('price01').textContent = (0.1 * price).toFixed(2);
        
    } catch (error) {
        console.error('❌ Ошибка получения цен с Binance:', error);
        // Используем резервные цены при ошибке
        await useFallbackPrices();
    }
}

// Резервные цены если API не работает
async function useFallbackPrices() {  // ← ДОБАВИТЬ async здесь
    console.log('🛡️ Использую резервные цены...');
    
    // Резервные цены по chainId
    const fallbackPricesByChainId = {
        // Ethereum сети
        '1': 4000,      // Ethereum Mainnet
        '11155111': 4000, // Sepolia Testnet
        '10': 4000,     // Optimism
        '42161': 4000,  // Arbitrum
        '8453': 4000,   // Base
        
        // Polygon сети
        '137': 0.2,     // Polygon Mainnet
        '80001': 0.2,   // Polygon Testnet
        
        // BNB сети
        '56': 600,      // BSC Mainnet
        '97': 600,      // BSC Testnet
        
        // Avalanche сети
        '43114': 40,    // Avalanche Mainnet
        '43113': 40,    // Avalanche Testnet
        
        // Fantom сети
        '250': 0.4,     // Fantom Mainnet
        '4002': 0.4     // Fantom Testnet
    };
    
    const chainId = await getCurrentChainId();  // ← теперь можно использовать await
    const price = fallbackPricesByChainId[chainId] || 1;
    
    document.getElementById('price001').textContent = (0.01 * price).toFixed(2);
    document.getElementById('price005').textContent = (0.05 * price).toFixed(2);
    document.getElementById('price01').textContent = (0.1 * price).toFixed(2);
}

// Функция для ручной проверки баланса
async function checkBalanceManually() {
    if (!currentUserAddress) {
        showNotification('Wallet not connected', 'error');
        return;
    }

    try {
        const balance = await provider.getBalance(currentUserAddress);
        const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
        
        showNotification(
            `Current balance: ${balanceInEth.toFixed(6)} ${currentNetwork.currency}`, 
            'success'
        );
        
        // Если баланс низкий, предлагаем покупку
        if (balanceInEth < 0.01) {
            setTimeout(() => {
                showBuyTokensModal(balanceInEth, 0.01);
            }, 1000);
        }
        
    } catch (error) {
        console.error('Manual balance check error:', error);
        showNotification('Error checking balance', 'error');
    }
}

// Добавляем кнопку проверки баланса в интерфейс
    // Обновленная функция добавления кнопки проверки баланса
function addBalanceCheckButton() {
    const walletSection = document.querySelector('.wallet-section');
    if (!walletSection) return;

    if (document.getElementById('balanceCheckBtn')) return;

    const balanceButton = document.createElement('button');
    balanceButton.id = 'balanceCheckBtn';
    balanceButton.className = 'btn btn-warning';
    balanceButton.innerHTML = '💰 Check Balance';
    balanceButton.onclick = async function() {
        await checkBalanceManually();
        
        // После проверки показываем рекомендации
        const recommended = await getRecommendedMinBalance();
        const balance = await provider.getBalance(currentUserAddress);
        const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
        
        if (balanceInEth < recommended) {
            setTimeout(() => {
                showBuyTokensModal(balanceInEth, recommended);
            }, 1000);
        }
    };
    balanceButton.style.marginLeft = '10px';
    
    walletSection.appendChild(balanceButton);
}

         // Валидация для регистрации
function validateRegistration() {
    if (!currentHash) {
        showNotification('Please select a file first', 'error');
        return false;
    }
    
    if (!contract) {
        showNotification('Contract not initialized', 'error');
        return false;
    }

    if (!isOwner && !userAgreed) {
        showNotification('❌ To perform this operation, you need to accept the user agreement', 'error');
        return false;
    }

    const availability = checkRegistrationAvailability();
    if ((currentProtection === 'BASIC' && !availability.basic) || 
        (currentProtection === 'COMMIT_REVEAL' && !availability.commit)) {
        showNotification('Selected registration method temporarily unavailable', 'error');
        return false;
    }

    return true;
}

       // ==================== ПРЕДВАРИТЕЛЬНАЯ ПРОВЕРКА БАЛАНСА ====================

// Автоматическая проверка баланса при подключении кошелька
    
async function checkAndNotifyBalance() {
    if (!currentUserAddress || !currentNetwork) return;
    
    try {
        const balance = await provider.getBalance(currentUserAddress);
        const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
        
        // Определяем рекомендуемый минимальный баланс для всех операций
        const recommendedMinBalance = await getRecommendedMinBalance();
        
        console.log(`💰 Баланс при подключении: ${balanceInEth.toFixed(6)} ${currentNetwork.currency}, рекомендовано: ${recommendedMinBalance}`);
        
        // Если баланс ниже рекомендуемого - показываем уведомление с задержкой
        if (balanceInEth < recommendedMinBalance) {
            setTimeout(() => {
                showBalanceWarningNotification(balanceInEth, recommendedMinBalance);
            }, 2000); // Задержка 2 секунды чтобы пользователь увидел успешное подключение
        }
        
    } catch (error) {
        console.error('Ошибка проверки баланса:', error);
    }
}
// Получение рекомендуемого минимального баланса для всех операций
async function getRecommendedMinBalance() {
    if (!contract) return 0.01;
    
    try {
        // Берем максимальную комиссию из всех операций + запас
        const basicFee = await contract.basicRegistrationFee();
        const verificationFee = await contract.verificationFee();
        const transferFee = await contract.transferFee();
        
        // Находим максимальную комиссию
        const maxFee = basicFee.gt(verificationFee) ? 
                      (basicFee.gt(transferFee) ? basicFee : transferFee) :
                      (verificationFee.gt(transferFee) ? verificationFee : transferFee);
        
        // Добавляем запас на газ (0.003 ETH)
        const gasBuffer = ethers.utils.parseEther('0.003');
        const totalRecommended = maxFee.add(gasBuffer);
        
        return parseFloat(ethers.utils.formatEther(totalRecommended));
        
    } catch (error) {
        console.error('Ошибка получения рекомендованного баланса:', error);
        return 0.01; // Значение по умолчанию
    }
}

// Показ предупреждения о низком балансе
     // === ЗАМЕНИТЬ ЭТУ ФУНКЦИЮ ===
function showBalanceWarningNotification(currentBalance, recommendedBalance) {
    // Сначала закрываем существующие уведомления о балансе
    closeExistingBalanceNotifications();
    
    const notification = document.createElement('div');
    notification.className = 'notification warning';
    notification.innerHTML = `
        <span>⚠️</span>
        <div style="flex: 1;">
            <strong>Low Balance Warning</strong><br>
            Current: ${currentBalance.toFixed(6)} ${currentNetwork.currency}<br>
            Recommended: ${recommendedBalance.toFixed(6)} ${currentNetwork.currency}<br>
            <button onclick="showBuyTokensModal(${currentBalance}, ${recommendedBalance})" 
                    style="margin-top: 8px; padding: 6px 12px; background: white; color: #D97706; border: none; border-radius: 4px; cursor: pointer; font-weight: 700;">
                Buy Tokens
            </button>
        </div>
        <button onclick="this.parentNode.remove()" 
                style="background: none; border: none; color: white; cursor: pointer; font-size: 16px; margin-left: 10px;">
            ✕
        </button>
    `;
    
    // Добавляем идентификатор для легкого поиска
    notification.id = 'balanceWarningNotification';
    
    document.body.appendChild(notification);
    
    // Автоматически скрываем через 15 секунд
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 15000);
}

// === ДОБАВИТЬ НОВУЮ ФУНКЦИЮ ===
function closeExistingBalanceNotifications() {
    const existingNotification = document.getElementById('balanceWarningNotification');
    if (existingNotification) {
        existingNotification.remove();
    }
}

// Быстрая проверка баланса (не блокирующая)
async function quickBalanceCheck() {
    try {
        const balance = await provider.getBalance(currentUserAddress);
        const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
        
        // Быстрая проверка - если баланс ОЧЕНЬ низкий
        return balanceInEth > 0.001; // Минимум 0.001 ETH
        
    } catch (error) {
        console.error('Quick balance check error:', error);
        return true; // При ошибке разрешаем продолжить
    }
}

// Быстрое предупреждение о балансе
function showQuickBalanceWarning() {
    const confirmContinue = confirm(
        `⚠️ Your balance may be insufficient for this operation.\n\n` +
        `It's recommended to check your balance first.\n\n` +
        `Do you want to continue anyway?`
    );
    
    if (!confirmContinue) {
        // Показываем модальное окно покупки
        provider.getBalance(currentUserAddress).then(balance => {
            const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
            showBuyTokensModal(balanceInEth, 0.01);
        });
        return false;
    }
    
    return true;
}
         
        // ==================== УЛУЧШЕННЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С META MASK ====================

        // Проверка доступности MetaMask при загрузке
        async function checkMetaMaskAvailability() {
            if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask) {
                // MetaMask доступен - автоматически подключаемся
                try {
                    await connectMetaMask();
                    await ensureCorrectNetwork();
                } catch (error) {
                    console.log('Auto-connection failed:', error);
                    showMetaMaskInstallInterface();
                }
            } else {
                // MetaMask не установлен
                showMetaMaskInstallInterface();
            }
        }

        // Подключение к MetaMask
       
async function connectMetaMask() {
    try {
        // Обновляем кнопку на текущий язык
        document.getElementById('connectWallet').innerHTML = currentLanguage === 'ru' 
            ? '⏳ Подключение...' 
            : '⏳ Connecting...';
        document.getElementById('connectWallet').disabled = true;

        if (typeof window.ethereum === 'undefined') {
            throw new Error('META_MASK_NOT_INSTALLED');
        }

        if (!window.ethereum.isMetaMask) {
            throw new Error('NOT_META_MASK');
        }

        // Запрашиваем подключение аккаунтов
        const accounts = await window.ethereum.request({ 
            method: 'eth_requestAccounts' 
        });

        if (accounts.length === 0) {
            throw new Error('NO_ACCOUNTS');
        }

        // Инициализируем провайдер
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        currentUserAddress = accounts[0];
        
        await updateWalletInfo();
        await initializeContract();
        await checkAndNotifyBalance();
        
        // Обновляем кнопку подключения с учетом языка
        document.getElementById('connectWallet').innerHTML = getTranslation('metamaskConnected');
        document.getElementById('connectWallet').title = getTranslation('metamaskConnected');
        document.getElementById('connectWallet').disabled = true;
        
        showNotification('✅ ' + (currentLanguage === 'ru' 
            ? 'MetaMask успешно подключен!' 
            : 'MetaMask successfully connected!'), 'success');
        
    } catch (error) {
        console.error('MetaMask connection error:', error);
        
        if (error.code === 4001) {
            showNotification('❌ ' + (currentLanguage === 'ru' 
                ? 'Вы отменили подключение MetaMask' 
                : 'You canceled MetaMask connection'), 'error');
        } else if (error.message === 'META_MASK_NOT_INSTALLED') {
            showMetaMaskInstallInterface();
            return; // Не сбрасываем кнопку, так как показываем интерфейс установки
        } else if (error.message === 'NOT_META_MASK') {
            showNotification('❌ ' + (currentLanguage === 'ru' 
                ? 'Обнаружен не-MetaMask кошелек. Пожалуйста, используйте MetaMask.' 
                : 'Non-MetaMask wallet detected. Please use MetaMask.'), 'error');
        } else {
            showNotification('❌ ' + (currentLanguage === 'ru' 
                ? 'Ошибка подключения MetaMask: ' 
                : 'MetaMask connection error: ') + error.message, 'error');
        }
        
        // Возвращаем кнопку в исходное состояние
        document.getElementById('connectWallet').innerHTML = getTranslation('connectWallet');
        document.getElementById('connectWallet').disabled = false;
    }
}
        // Интерфейс установки MetaMask
        // Интерфейс установки MetaMask
function showMetaMaskInstallInterface() {
    const connectBtn = document.getElementById('connectWallet');
    connectBtn.innerHTML = currentLanguage === 'ru' ? '📱 Установить MetaMask' : '📱 Install MetaMask';
    connectBtn.onclick = installMetaMask;
    connectBtn.disabled = false;
    
    // Показываем информационное сообщение для новичков с учетом языка
    const isRussian = currentLanguage === 'ru';
    document.getElementById('welcomeInstruction').innerHTML = `
        <div style="background: rgba(255,255,255,0.1); padding: 25px; border-radius: 15px; margin-top: 20px; text-align: left;">
            <h4 style="margin-bottom: 15px; color: #FEF3C7;">🚀 ${isRussian ? 'Для работы с приложением требуется MetaMask!' : 'MetaMask is required to work with the application!'}</h4>
            
            <div style="margin-bottom: 15px;">
                <h5 style="color: #FEF3C7; margin-bottom: 8px;">🦊 ${isRussian ? 'Что такое MetaMask?' : 'What is MetaMask?'}</h5>
                <p>${isRussian ? 'MetaMask - это безопасный кошелек для работы с блокчейном Ethereum. Это расширение для браузера, которое позволяет безопасно управлять вашими активами.' : 'MetaMask is a secure wallet for working with Ethereum blockchain. It\'s a browser extension that allows you to securely manage your assets.'}</p>
            </div>
            
            <div style="margin-bottom: 15px;">
                <h5 style="color: #FEF3C7; margin-bottom: 8px;">🔒 ${isRussian ? 'Это безопасно?' : 'Is it safe?'}</h5>
                <p>${isRussian ? 'Да! MetaMask использует современное шифрование. Только вы имеете доступ к вашим данным через сид-фразу.' : 'Yes! MetaMask uses modern encryption. Only you have access to your data through the seed phrase.'}</p>
            </div>
            
            <div style="background: rgba(245, 158, 11, 0.2); padding: 15px; border-radius: 8px; border: 1px solid #F59E0B; margin: 15px 0;">
                <strong>📋 ${isRussian ? 'После установки MetaMask:' : 'After installing MetaMask:'}</strong>
                <ol style="margin: 10px 0 0 15px;">
                    <li><strong>${isRussian ? 'ОБНОВИТЕ СТРАНИЦУ' : 'REFRESH THE PAGE'}</strong> (${isRussian ? 'нажмите F5' : 'press F5'})</li>
                    <li>${isRussian ? 'Нажмите "Подключить MetaMask"' : 'Click "Connect MetaMask"'}</li>
                    <li>${isRussian ? 'Подтвердите подключение в MetaMask' : 'Confirm connection in MetaMask'}</li>
                </ol>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                <div style="background: rgba(245, 158, 11, 0.2); padding: 15px; border-radius: 8px; border: 1px solid #F59E0B;">
                    <strong>🦊 ${isRussian ? 'Chrome / Brave' : 'Chrome / Brave'}</strong>
                    <p style="margin: 8px 0 0 0; font-size: 0.9em;">${isRussian ? 'Установите расширение из магазина' : 'Install extension from store'}</p>
                </div>
                <div style="background: rgba(59, 130, 246, 0.2); padding: 15px; border-radius: 8px; border: 1px solid #3B82F6;">
                    <strong>📱 ${isRussian ? 'Мобильное приложение' : 'Mobile App'}</strong>
                    <p style="margin: 8px 0 0 0; font-size: 0.9em;">${isRussian ? 'Скачайте из App Store или Google Play' : 'Download from App Store or Google Play'}</p>
                </div>
            </div>
        </div>
    `;
}
        // Установка MetaMask
       // Установка MetaMask
function installMetaMask() {
    window.open('https://metamask.io/download.html', '_blank');
    
    // Показываем инструкцию после установки с учетом языка
    const isRussian = currentLanguage === 'ru';
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    
    const content = document.createElement('div');
    content.className = 'modal-content';
    
    content.innerHTML = `
        <h3 style="margin-bottom: 20px; color: #1E293B;">🎉 ${isRussian ? 'MetaMask устанавливается!' : 'MetaMask is installing!'}</h3>
        
        <div style="text-align: left; margin-bottom: 20px;">
            <div style="background: #D1FAE5; padding: 15px; border-radius: 8px; border: 2px solid #10B981; margin-bottom: 15px;">
                <h5 style="color: #065F46; margin-bottom: 10px;">📋 ${isRussian ? 'Следующие шаги:' : 'Next steps:'}</h5>
                <ol style="margin: 0; padding-left: 20px;">
                    <li><strong>${isRussian ? 'Завершите установку MetaMask' : 'Complete MetaMask installation'}</strong> ${isRussian ? 'в браузере' : 'in browser'}</li>
                    <li><strong>${isRussian ? 'Создайте новый кошелек' : 'Create a new wallet'}</strong> ${isRussian ? 'или импортируйте существующий' : 'or import existing one'}</li>
                    <li><strong>${isRussian ? 'ОБЯЗАТЕЛЬНО: ОБНОВИТЕ СТРАНИЦУ' : 'MANDATORY: REFRESH THE PAGE'}</strong> (F5 ${isRussian ? 'или' : 'or'} Ctrl+R)</li>
                    <li>${isRussian ? 'Нажмите "Подключить MetaMask"' : 'Click "Connect MetaMask"'}</li>
                    <li>${isRussian ? 'Подтвердите подключение в MetaMask' : 'Confirm connection in MetaMask'}</li>
                </ol>
            </div>
            
            <div style="background: #FEF3C7; padding: 12px; border-radius: 6px; border: 2px solid #F59E0B;">
                <strong>💡 ${isRussian ? 'Важно:' : 'Important:'}</strong> ${isRussian ? 'После установки расширения страница должна быть обновлена!' : 'After installing the extension, the page must be refreshed!'}
            </div>
        </div>
        
        <button onclick="this.closest('.modal-overlay').remove()" 
                style="padding: 12px 24px; border: none; background: #3B82F6; 
                       color: white; border-radius: 8px; cursor: pointer; font-weight: 700;">
            ${isRussian ? 'Понятно' : 'Got it'}
        </button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
}

        // Проверка и переключение на нужную сеть
      // Проверка и переключение на нужную сеть
async function ensureCorrectNetwork() {
    try {
        // Получаем текущую сеть
        const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
        const currentChainIdNum = parseInt(currentChainId, 16);
        
        // Проверяем, поддерживается ли текущая сеть
        const network = Object.values(NETWORKS).find(n => parseInt(n.chainId) === currentChainIdNum && n.enabled);
        
        if (network && network.contractAddress) {
            // Сеть поддерживается и есть контракт
            document.getElementById('currentNetworkName').textContent = network.name;
            document.getElementById('networkStatus').textContent = currentLanguage === 'ru' ? 'Подключено' : 'Connected';
            showNotification(`✅ ${currentLanguage === 'ru' ? 'Сеть:' : 'Network:'} ${network.name}`, 'success');
            return true;
        }
        
        // Если сеть не поддерживается, показываем выбор сети
        showNetworkSelection();
        return false;
        
    } catch (error) {
        console.error('Network check error:', error);
        showNotification(`❌ ${currentLanguage === 'ru' ? 'Ошибка проверки сети' : 'Network check error'}`, 'error');
        return false;
    }
}
        // Обновление информации о кошельке
       // Обновление информации о кошельке
async function updateWalletInfo() {
    if (!provider || !currentUserAddress) return;
    
    try {
        const balance = await provider.getBalance(currentUserAddress);
        const formattedBalance = ethers.utils.formatEther(balance).substring(0, 6);
        const currency = currentNetwork ? currentNetwork.currency : 'ETH';
        
        document.getElementById('walletAddress').textContent = 
            `${currentUserAddress.substring(0, 6)}...${currentUserAddress.substring(currentUserAddress.length - 4)}`;
        document.getElementById('walletBalance').textContent = 
            `${formattedBalance} ${currency}`;
        document.getElementById('walletInfo').style.display = 'block';
        
    } catch (error) {
        console.error('Wallet info update error:', error);
    }
}
        // ==================== АНИМАЦИЯ ЗВЁЗД ДЛЯ ЯЗЫКОВОЙ ПАНЕЛИ ====================

function createStars() {
    const starsContainer = document.getElementById('starsContainer');
    if (!starsContainer) return;
    
    // Очищаем контейнер (на случай повторного вызова)
    starsContainer.innerHTML = '';
    
    // Создаем 150 звёзд
    for (let i = 0; i < 150; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        
        // Случайная позиция
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        
        // Случайный размер (1-3px)
        const size = Math.random() * 2 + 1;
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        
        // Случайная длительность анимации (2-5 секунд)
        star.style.setProperty('--duration', Math.random() * 3 + 2 + 's');
        
        // Случайная задержка начала анимации
        star.style.animationDelay = Math.random() * 5 + 's';
        
        starsContainer.appendChild(star);
    }
}

// Функция для создания сетки блокчейн-соединений
function createBlockchainConnections() {
    const starsContainer = document.getElementById('starsContainer');
    if (!starsContainer) return;
    
    // Создаем SVG для соединений
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '1';
    
    starsContainer.appendChild(svg);
    
    // Создаем несколько соединений
    for (let i = 0; i < 20; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        
        // Случайные координаты
        const x1 = Math.random() * 100;
        const y1 = Math.random() * 100;
        const x2 = Math.random() * 100;
        const y2 = Math.random() * 100;
        
        line.setAttribute('x1', x1 + '%');
        line.setAttribute('y1', y1 + '%');
        line.setAttribute('x2', x2 + '%');
        line.setAttribute('y2', y2 + '%');
        line.setAttribute('stroke', 'rgba(59, 130, 246, 0.2)');
        line.setAttribute('stroke-width', '1');
        line.setAttribute('stroke-dasharray', '5,5');
        
        // Анимация соединения
        line.style.animation = `pulseConnection ${Math.random() * 4 + 2}s ease-in-out infinite`;
        
        svg.appendChild(line);
    }
}

// Анимация для соединений
const style = document.createElement('style');
style.textContent = `
    @keyframes pulseConnection {
        0%, 100% { opacity: 0.2; stroke: rgba(59, 130, 246, 0.2); }
        50% { opacity: 0.6; stroke: rgba(59, 130, 246, 0.5); }
    }
`;
document.head.appendChild(style);

        // ==================== ОСНОВНЫЕ ФУНКЦИИ ПРИЛОЖЕНИЯ ====================

        // Инициализация приложения
async function initializeApp() {
    // Сначала проверяем язык
    checkSavedLanguage();
    
    // Создаем анимированные звёзды и соединения
    createStars();
    createBlockchainConnections();
    
    // Затем продолжаем обычную инициализацию
    document.querySelector('.welcome-version').textContent = `VER. ${APP_VERSION}`;
    
    if (typeof ethers === 'undefined') {
        showNotification('Ethers.js library not loaded', 'error');
        return;
    }
    
    await checkMetaMaskAvailability();
    addBalanceCheckButton();
}

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DApp initialized');
            setupNavigation();
            setupEventListeners();
            checkUserAgreement();
        });

        // Проверка состояния пользовательского соглашения
        function checkUserAgreement() {
            if (currentUserAddress) {
                const savedAgreement = localStorage.getItem(`userAgreed_${currentUserAddress.toLowerCase()}`);
                userAgreed = savedAgreement === 'true';
            }
            updateUserInterface();
        }

        // Обновление интерфейса в зависимости от статуса пользователя
            function updateUserInterface() {
    const userOnlyElements = document.querySelectorAll('.user-only');
    const clientOnlyElements = document.querySelectorAll('.client-only');
    const ownerOnlyElements = document.querySelectorAll('.owner-only');
    const agreementNavItem = document.getElementById('agreementNavItem');
    
    // Сначала скрываем все элементы
    userOnlyElements.forEach(element => element.style.display = 'none');
    clientOnlyElements.forEach(element => element.style.display = 'none');
    ownerOnlyElements.forEach(element => element.style.display = 'none');
    
    // Если пользователь - владелец контракта
    if (isOwner) {
        // Показываем все функциональные элементы и панель владельца
        userOnlyElements.forEach(element => element.style.display = 'flex');
        ownerOnlyElements.forEach(element => element.style.display = 'flex');
        // Скрываем соглашение
        if (agreementNavItem) agreementNavItem.style.display = 'none';
        
        document.getElementById('welcomeInstruction').textContent = 'Select a section from the left menu to get started with the application';
    } 
    // Если обычный пользователь с принятым соглашением
    else if (userAgreed) {
        // Показываем функциональные элементы
        userOnlyElements.forEach(element => element.style.display = 'flex');
        // Скрываем соглашение и панель владельца
        if (agreementNavItem) agreementNavItem.style.display = 'none';
        ownerOnlyElements.forEach(element => element.style.display = 'none');
        
        document.getElementById('welcomeInstruction').textContent = 'Select a section from the left menu to get started with the application';
    } 
    // Если обычный пользователь без соглашения
    else {
        // Показываем только информационные разделы и соглашение
        clientOnlyElements.forEach(element => element.style.display = 'flex');
        // Скрываем функциональные элементы и панель владельца
        userOnlyElements.forEach(element => element.style.display = 'none');
        ownerOnlyElements.forEach(element => element.style.display = 'none');
        
        document.getElementById('welcomeInstruction').textContent = 'To get started, you need to go to the "Agreement" menu item, study it and sign it';
    }
}

        function setupNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Проверяем доступ к функциональным разделам
                    if (this.classList.contains('user-only') && !userAgreed && !isOwner) {
                        showNotification('❌ To access this section, you need to accept the user agreement', 'error');
                        return;
                    }
                    
                    if (this.id === 'ownerNavItem' && !isOwner) {
                        showNotification('❌ You do not have permission to access the owner panel', 'error');
                        return;
                    }
                    
                    navItems.forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                    
                    document.getElementById('welcomeScreen').style.display = 'none';
                    
                    document.querySelectorAll('.tab-content').forEach(tab => {
                        tab.classList.remove('active');
                        tab.style.display = 'none';
                    });
                    
                    const tabId = this.getAttribute('data-tab') + 'Tab';
                    const tabElement = document.getElementById(tabId);
                    
                    if (tabElement) {
                        tabElement.classList.add('active');
                        tabElement.style.display = 'flex';
                    }
                });
            });
        }

      function setupEventListeners() {
    // СУЩЕСТВУЮЩИЕ ОБРАБОТЧИКИ СОГЛАШЕНИЯ
    document.getElementById('agreeCheckbox').addEventListener('change', function() {
        document.getElementById('acceptAgreement').disabled = !this.checked;
    });
    
    document.getElementById('acceptAgreement').addEventListener('click', function() {
        if (currentUserAddress) {
            userAgreed = true;
            localStorage.setItem(`userAgreed_${currentUserAddress.toLowerCase()}`, 'true');
            updateUserInterface();
            showNotification('✅ Agreement accepted! Now you have access to all application functions', 'success');
            document.querySelector('[data-tab="about"]').click();
        } else {
            showNotification('❌ Error: wallet address not defined', 'error');
        }
    });

    // ОБРАБОТЧИКИ ВЫБОРА МЕТОДА РЕГИСТРАЦИИ
    document.querySelectorAll('.protection-option').forEach(option => {
        option.addEventListener('click', function() {
            if (this.classList.contains('disabled')) return;
            document.querySelectorAll('.protection-option').forEach(opt => opt.classList.remove('active'));
            this.classList.add('active');
            currentProtection = this.getAttribute('data-protection');
            updateRegistrationUI();
        });
    });

    // ОБРАБОТЧИКИ ФАЙЛОВ
    const fileInput = document.getElementById('fileInput');
    const fileUpload = document.getElementById('fileUpload');

    fileInput.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) processFile(files[0]);
    });

    fileUpload.addEventListener('dragover', function(e) {
        e.preventDefault();
        fileUpload.classList.add('dragover');
    });

    fileUpload.addEventListener('dragleave', function(e) {
        e.preventDefault();
        fileUpload.classList.remove('dragover');
    });

    fileUpload.addEventListener('drop', function(e) {
        e.preventDefault();
        fileUpload.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            processFile(files[0]);
            fileUpload.classList.add('file-selected');
        }
    });

    // ОБРАБОТЧИКИ ХЭША
    document.getElementById('toggleHash').addEventListener('click', toggleHashVisibility);
    document.getElementById('copyHash').addEventListener('click', copyHashToClipboard);
    
    // НОВЫЕ ОБРАБОТЧИКИ ДЛЯ ВАЛИДАЦИИ ПОЛЕЙ
    document.getElementById('verifyHash').addEventListener('input', function() {
        validateVerifyHash();
        showInputHint('verifyHashHint', this.value);
    });
    
    document.getElementById('transferHash').addEventListener('input', function() {
        validateTransferFields();
        showInputHint('transferHashHint', this.value);
    });
    
    document.getElementById('newOwnerAddress').addEventListener('input', function() {
        validateTransferFields();
        showInputHint('newOwnerAddressHint', this.value);
    });
    
    document.getElementById('newContractOwnerAddress').addEventListener('input', function() {
        validateContractTransferFields();
        showInputHint('newContractOwnerAddressHint', this.value);
    });
    
    // ОБРАБОТЧИКИ ДЛЯ КНОПОК ОЧИСТКИ
    setupClearButtons();
    
    // ОБРАБОТЧИКИ ОПЕРАЦИЙ С ПРОВЕРКОЙ БАЛАНСА
    document.getElementById('registerContent').addEventListener('click', function() {
        console.log('=== КНОПКА РЕГИСТРАЦИИ НАЖАТА ===');
        
        if (!validateRegistration()) {
            console.log('❌ Проверка не пройдена');
            return;
        }
        
        console.log('✅ Проверка пройдена');
        
        quickBalanceCheck().then(hasSufficientBalance => {
            if (hasSufficientBalance) {
                console.log('✅ Баланс достаточен - запускаю регистрацию');
                registerContent();
            } else {
                console.log('⚠️ Баланс может быть недостаточным');
                showQuickBalanceWarning().then(shouldContinue => {
                    if (shouldContinue) {
                        console.log('✅ Пользователь решил продолжить - запускаю регистрацию');
                        registerContent();
                    } else {
                        console.log('❌ Пользователь отменил - показываю покупку токенов');
                    }
                });
            }
        });
    });

    document.getElementById('verifyContent').addEventListener('click', function() {
        console.log('=== КНОПКА ВЕРИФИКАЦИИ НАЖАТА ===');
        
        if (!validateVerifyHash()) {
            console.log('❌ Проверка хэша не пройдена');
            return;
        }
        
        console.log('✅ Проверка хэша пройдена');
        
        quickBalanceCheck().then(hasSufficientBalance => {
            if (hasSufficientBalance) {
                console.log('✅ Баланс достаточен - запускаю верификацию');
                verifyContent();
            } else {
                console.log('⚠️ Баланс может быть недостаточным');
                showQuickBalanceWarning().then(shouldContinue => {
                    if (shouldContinue) {
                        console.log('✅ Пользователь решил продолжить - запускаю верификацию');
                        verifyContent();
                    } else {
                        console.log('❌ Пользователь отменил - показываю покупку токенов');
                    }
                });
            }
        });
    });

    document.getElementById('transferOwnership').addEventListener('click', function() {
        console.log('=== КНОПКА ПЕРЕДАЧИ ПРАВ НАЖАТА ===');
        
        if (!validateTransferFields()) {
            console.log('❌ Проверка полей передачи не пройдена');
            return;
        }
        
        console.log('✅ Проверка полей передачи пройдена');
        
        quickBalanceCheck().then(hasSufficientBalance => {
            if (hasSufficientBalance) {
                console.log('✅ Баланс достаточен - запускаю передачу прав');
                transferOwnership();
            } else {
                console.log('⚠️ Баланс может быть недостаточным');
                showQuickBalanceWarning().then(shouldContinue => {
                    if (shouldContinue) {
                        console.log('✅ Пользователь решил продолжить - запускаю передачу прав');
                        transferOwnership();
                    } else {
                        console.log('❌ Пользователь отменил - показываю покупку токенов');
                    }
                });
            }
        });
    });

    document.getElementById('revealContent').addEventListener('click', function() {
        console.log('=== КНОПКА REVEAL НАЖАТА ===');
        
        quickBalanceCheck().then(hasSufficientBalance => {
            if (hasSufficientBalance) {
                console.log('✅ Баланс достаточен - запускаю reveal');
                revealContent();
            } else {
                console.log('⚠️ Баланс может быть недостаточным');
                showQuickBalanceWarning().then(shouldContinue => {
                    if (shouldContinue) {
                        console.log('✅ Пользователь решил продолжить - запускаю reveal');
                        revealContent();
                    } else {
                        console.log('❌ Пользователь отменил - показываю покупку токенов');
                    }
                });
            }
        });
    });
    
    // ОБРАБОТЧИКИ ДЛЯ ПАНЕЛИ ВЛАДЕЛЬЦА
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            if (!this.classList.contains('disabled')) {
                const mode = parseInt(this.getAttribute('data-mode'));
                setRegistrationMode(mode);
            }
        });
    });
    
    document.getElementById('updateAllFees').addEventListener('click', updateAllFees);
    document.getElementById('withdrawFees').addEventListener('click', withdrawFees);
    document.getElementById('stopContract').addEventListener('click', stopContract);
    document.getElementById('activateContract').addEventListener('click', activateContract);
    document.getElementById('transferContractOwnership').addEventListener('click', transferContractOwnership);
    
    // ОБРАБОТЧИК ДЛЯ КНОПКИ СМЕНЫ СЕТИ
    document.getElementById('switchNetworkBtn').addEventListener('click', function() {
        showNetworkSelection();
    });
    
    // ОБРАБОТЧИКИ ДЛЯ ПОКУПКИ ТОКЕНОВ
    setupTokenPurchaseListeners();
}

       function showNetworkSelection() {
    const enabledNetworks = Object.values(NETWORKS).filter(n => n.enabled);
    const isRussian = currentLanguage === 'ru';
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    
    const content = document.createElement('div');
    content.className = 'modal-content';
    
    let html = `<h3 style="margin-bottom: 20px; color: #1E293B;">${isRussian ? 'Выбор сети' : 'Select Network'}</h3>`;
    
    enabledNetworks.forEach(network => {
        const networkKey = Object.keys(NETWORKS).find(key => NETWORKS[key] === network);
        const hasContract = network.contractAddress;
        
        html += `
            <button onclick="switchToNetwork(${networkKey})"
                    style="width: 100%; padding: 15px; margin: 5px 0; border: 2px solid ${hasContract ? '#10B981' : '#EF4444'}; 
                           border-radius: 10px; background: white; cursor: pointer; 
                           transition: all 0.3s ease; text-align: left;">
                <div style="display: flex; justify-content: between; align-items: center;">
                    <div>
                        <strong>${network.name}</strong><br>
                        <small style="color: ${hasContract ? '#059669' : '#EF4444'}">
                            ${hasContract ? 
                                (isRussian ? '✅ Контракт развернут' : '✅ Contract deployed') : 
                                (isRussian ? '❌ Контракт недоступен' : '❌ Contract not available')}
                        </small>
                    </div>
                    <div style="margin-left: auto; color: #6B7280;">
                        ${network.currency}
                    </div>
                </div>
            </button>
        `;
    });
    
    html += `
        <button onclick="this.closest('.modal-overlay').remove()" 
                style="margin-top: 15px; padding: 10px 20px; border: none; 
                       background: #6B7280; color: white; border-radius: 8px; cursor: pointer;">
            ${isRussian ? 'Отмена' : 'Cancel'}
        </button>
    `;
    
    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);
}
      

      
function showNotification(message, type = 'info') {
    // Закрываем предыдущие уведомления того же типа
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => {
        if (notification.textContent.includes(message.substring(0, 20))) {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }
    });
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <span>${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
        <span>${message}</span>
        <button onclick="this.parentNode.remove()" 
                style="background: none; border: none; color: white; cursor: pointer; font-size: 16px; margin-left: 10px;">
            ✕
        </button>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentNode) notification.parentNode.removeChild(notification);
    }, 5000);
}

       async function initializeContract() {
    if (!provider) {
        console.log('Provider not available');
        return;
    }
    
    try {
        const network = await provider.getNetwork();
        const chainIdNum = network.chainId;
        
        console.log('Current chainId:', chainIdNum);
        
        currentNetwork = Object.values(NETWORKS).find(n => parseInt(n.chainId) === chainIdNum && n.enabled);
        
        if (!currentNetwork) {
            console.log('Network not supported:', chainIdNum);
            document.getElementById('currentNetworkName').textContent = 'Unsupported network';
            document.getElementById('networkStatus').textContent = 'Error';
            updateContractStatus(false, true);
            applyTranslations();
            return;
        }

        if (!currentNetwork.contractAddress) {
            console.log('No contract address for network:', currentNetwork.name);
            document.getElementById('currentNetworkName').textContent = currentNetwork.name;
            document.getElementById('networkStatus').textContent = 'Contract not available';
            updateContractStatus(false, true);
            applyTranslations();
            return;
        }

        console.log('Initializing contract for network:', currentNetwork.name);
        
        document.getElementById('currentNetworkName').textContent = currentNetwork.name;
        document.getElementById('networkStatus').textContent = 'Connected';
        
        // ИНИЦИАЛИЗАЦИЯ КОНТРАКТА
        contract = new ethers.Contract(currentNetwork.contractAddress, CONTRACT_ABI, signer || provider);

         await checkContractState();
         applyTranslations();

       
        await checkIfOwner();
        await loadContractInfo();
         // ОБНОВЛЕНИЕ ВАЛЮТЫ
        await updateFeeCurrencies(); 
        
        
        
        console.log('Contract initialized successfully');
        
    } catch (error) {
        console.error('Contract initialization error:', error);
        updateContractStatus(false, true);
        applyTranslations();
    }
}
        // ==================== ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ ====================

        async function processFile(file) {
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            document.getElementById('fileType').textContent = file.type || 'Unknown type';
            
            currentHash = '';
            document.getElementById('contentHashDisplay').textContent = 'Calculating hash...';
            document.getElementById('contentHashDisplay').className = 'hash-display hash-masked';
            document.getElementById('hashControls').style.display = 'none';
            document.getElementById('registerContent').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            updateProgress(0);

            try {
                const hash = await calculateFileHash(file);
                currentHash = hash;
                document.getElementById('contentHashDisplay').textContent = hash;
                document.getElementById('contentHashDisplay').className = 'hash-display hash-masked';
                document.getElementById('hashControls').style.display = 'flex';
                
                const availability = checkRegistrationAvailability();
                if ((currentProtection === 'BASIC' && availability.basic) || 
                    (currentProtection === 'COMMIT_REVEAL' && availability.commit)) {
                    document.getElementById('registerContent').disabled = false;
                }
                
                isHashVisible = false;
                updateProgress(100);
                
                const contentExists = await checkContentExists(currentHash);
                if (contentExists) {
                    const resultElement = document.getElementById('registerResult');
                    resultElement.innerHTML = '❌ Content ALREADY registered in blockchain';
                    resultElement.className = 'result error';
                    resultElement.style.display = 'block';
                    autoHideError('registerResult');
                }
                
                if (currentProtection === 'COMMIT_REVEAL') {
                    updateCommitHash();
                }
                
                showNotification('File hash successfully calculated!', 'success');
                
            } catch (error) {
                document.getElementById('contentHashDisplay').textContent = 'Hash calculation error';
                document.getElementById('contentHashDisplay').className = 'hash-display';
                document.getElementById('hashControls').style.display = 'none';
                showNotification('Error calculating file hash: ' + error.message, 'error');
                updateProgress(0);
            }
        }

        async function calculateFileHash(file) {
            return new Promise((resolve, reject) => {
                try {
                    const MAX_SIMPLE_SIZE = 10 * 1024 * 1024;
                    updateProgress(0);

                    if (file.size <= MAX_SIMPLE_SIZE) {
                        const reader = new FileReader();

                        reader.onloadstart = () => updateProgress(5);
                        reader.onprogress = e => {
                            if (e.lengthComputable) {
                                const percent = (e.loaded / e.total) * 100;
                                updateProgress(5 + percent * 0.9);
                            }
                        };

                        reader.onload = e => {
                            try {
                                const arrayBuffer = e.target.result;
                                const hash = sha256(arrayBuffer);
                                updateProgress(100);
                                resolve(hash);
                            } catch (err) {
                                reject(new Error("Hash calculation error: " + err.message));
                            }
                        };

                        reader.onerror = () => reject(new Error("File reading error"));
                        reader.readAsArrayBuffer(file);
                    } else {
                        const chunkSize = 4 * 1024 * 1024;
                        const chunks = Math.ceil(file.size / chunkSize);
                        let currentChunk = 0;

                        const reader = new FileReader();
                        const shaObj = sha256.create();

                        reader.onload = e => {
                            if (e.target.result) {
                                shaObj.update(new Uint8Array(e.target.result));
                                currentChunk++;

                                const percent = Math.min(100, (currentChunk / chunks) * 100);
                                updateProgress(percent);

                                if (currentChunk < chunks) {
                                    loadNextChunk();
                                } else {
                                    const hash = shaObj.hex();
                                    updateProgress(100);
                                    resolve(hash);
                                }
                            }
                        };

                        reader.onerror = () => reject(new Error("File reading error"));

                        function loadNextChunk() {
                            const start = currentChunk * chunkSize;
                            const end = Math.min(file.size, start + chunkSize);
                            reader.readAsArrayBuffer(file.slice(start, end));
                        }

                        loadNextChunk();
                    }
                } catch (error) {
                    reject(new Error("File processing error: " + error.message));
                }
            });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progress = document.getElementById('progress');
            
            progressBar.style.display = 'block';
            progress.style.width = percent + '%';
            
            if (percent >= 100) {
                setTimeout(() => progressBar.style.display = 'none', 1000);
            }
        }

        function hexToBytes32(hexString) {
            if (hexString.startsWith('0x')) hexString = hexString.substring(2);
            hexString = hexString.padStart(64, '0');
            return '0x' + hexString;
        }

               // ==================== ФУНКЦИИ РЕГИСТРАЦИИ КОНТЕНТА ====================

           async function registerContent() {
    if (!currentHash) {
        showNotification('Please select a file first', 'error');
        return;
    }
    
    if (!contract) {
        showNotification('Contract not initialized', 'error');
        return;
    }

    if (!isOwner && !userAgreed) {
        showNotification('❌ To perform this operation, you need to accept the user agreement', 'error');
        return;
    }

    const availability = checkRegistrationAvailability();
    if ((currentProtection === 'BASIC' && !availability.basic) || 
        (currentProtection === 'COMMIT_REVEAL' && !availability.commit)) {
        showNotification('Selected registration method temporarily unavailable', 'error');
        return;
    }

    try {
        document.getElementById('registerLoading').style.display = 'block';
        document.getElementById('registerContent').disabled = true;
        
        const contentExists = await checkContentExists(currentHash);
        if (contentExists) {
            document.getElementById('registerResult').innerHTML = '❌ Content ALREADY registered in blockchain';
            document.getElementById('registerResult').className = 'result error';
            document.getElementById('registerResult').style.display = 'block';
            autoHideError('registerResult');
            return;
        }

        const currentUser = await signer.getAddress();
        
        if (currentProtection === 'COMMIT_REVEAL') {
            console.log('=== COMMIT_REVEAL START ===');
            console.log('1. Data verification:');
            console.log('   - currentCommitHash:', currentCommitHash);
            console.log('   - currentHash:', currentHash);
            console.log('   - currentSalt:', currentSalt);
            console.log('   - currentUser:', currentUser);
            
            if (!currentCommitHash) {
                console.log('❌ Error: commit hash not calculated');
                showNotification('Error: commit hash not calculated', 'error');
                return;
            }
            
            const commitFee = await contract.commitFee();
            console.log('2. Commit fee:', commitFee.toString());
            
            try {
                console.log('3. Pre-check callStatic...');
                await contract.callStatic.registerContentCommit(hexToBytes32(currentCommitHash), {
                    value: commitFee
                });
                console.log('✅ callStatic check passed');
            } catch (preCheckError) {
                console.log('❌ callStatic error:', preCheckError);
                if (preCheckError.message.includes('CommitHashAlreadyExist')) {
                    showNotification('Commit with this hash already exists', 'error');
                    return;
                }
                throw preCheckError;
            }
            
            updateCommitRevealStatus('commit');
            
            console.log('4. Sending commit transaction...');
            const tx = await contract.registerContentCommit(hexToBytes32(currentCommitHash), {
                value: commitFee,
                gasLimit: getGasLimit('COMMIT')
            });
            console.log('   TX hash:', tx.hash);
            
            showNotification('Commit transaction sent...', 'info');
            
            console.log('5. Waiting for transaction confirmation...');
            const receipt = await tx.wait();
            console.log('   Receipt:', receipt);
            console.log('   Status:', receipt.status);
            console.log('   Block Number:', receipt.blockNumber);
            console.log('   Gas Used:', receipt.gasUsed.toString());
            
            commitBlockNumber = receipt.blockNumber;
            
            console.log('6. Checking commit in blockchain...');
            const commitInfo = await contract.commitInfo(hexToBytes32(currentCommitHash));
            console.log('   Commit Info:', commitInfo);
            const commitOwner = commitInfo.commitowner;
            console.log('   Commit Owner:', commitOwner);
            
            if (commitOwner.toLowerCase() === currentUser.toLowerCase()) {
                console.log('✅ Commit successfully verified - owner matches');
                showNotification('✅ Commit successfully completed! Waiting for reveal delay...', 'success');
                showCommitInfo(commitOwner, commitBlockNumber);
                startRevealCountdown();
            } else {
                console.log('❌ Error: commit owner does not match');
                console.log('   Expected:', currentUser.toLowerCase());
                console.log('   Received:', commitOwner.toLowerCase());
                showNotification('❌ Error: commit performed by different address', 'error');
            }
            
            console.log('=== COMMIT_REVEAL END ===');
        } else {
            // BASIC регистрация
            const contentHashBytes32 = hexToBytes32(currentHash);
            const registrationFee = await contract.basicRegistrationFee();
            
            try {
                await contract.callStatic.registerContent(contentHashBytes32, {
                    value: registrationFee
                });
            } catch (preCheckError) {
                if (preCheckError.message.includes('ContentAlreadyRegistered')) {
                    showNotification('Content already registered', 'error');
                    return;
                }
                throw preCheckError;
            }
            
            const tx = await contract.registerContent(contentHashBytes32, {
                value: registrationFee,
                gasLimit: getGasLimit('BASIC')
            });
            
            showNotification('Registration transaction sent...', 'info');
            
            const receipt = await tx.wait();
            
            const block = await provider.getBlock(receipt.blockNumber);
            const registrationTime = new Date(block.timestamp * 1000).toLocaleString('ru-RU');
            
            const reportData = {
                operation: "registration",
                contentHash: currentHash,
                protectionType: currentProtection,
                registrationDate: registrationTime,
                blockNumber: receipt.blockNumber,
                owner: currentUser
            };
            
            createReport("registration", reportData, receipt);
            
            const registrationInfo = {
                status: "SUCCESSFULLY REGISTERED",
                contentHash: currentHash,
                owner: currentUser,
                registrationDate: registrationTime,
                transactionHash: receipt.transactionHash,
                blockNumber: receipt.blockNumber
            };
            
            showRegistrationResult(registrationInfo, receipt);
            showNotification('Content successfully registered!', 'success');
            
            await loadContractInfo();
            if (isOwner) await loadOwnerInfo();
        }
        
    } catch (error) {
        console.error('Registration error:', error);
        handleRegistrationError(error);
    } finally {
        document.getElementById('registerLoading').style.display = 'none';
        document.getElementById('registerContent').disabled = !currentHash;
    }
}

        async function revealContent() {
            if (!currentHash || !currentSalt || !currentCommitHash) {
                showNotification('Error: missing required data for reveal', 'error');
                return;
            }

            if (!isOwner && !userAgreed) {
                showNotification('❌ To perform this operation, you need to accept the user agreement', 'error');
                return;
            }

            try {
                document.getElementById('registerLoading').style.display = 'block';
                document.getElementById('revealContent').disabled = true;

                const contentExists = await checkContentExists(currentHash);
                if (contentExists) {
                    showNotification('Content already registered', 'error');
                    return;
                }

                const revealFee = await contract.revealFee();
                const currentUser = await signer.getAddress();

                updateCommitRevealStatus('reveal');

                const tx = await contract.registerContentReveal(
                    hexToBytes32(currentCommitHash),
                    hexToBytes32(currentHash),
                    hexToBytes32(currentSalt),
                    {
                        value: revealFee,
                        gasLimit: getGasLimit('REVEAL')
                    }
                );

                showNotification('⏳ Reveal transaction sent...', 'info');
                const receipt = await tx.wait();

                stopRevealCountdown();

                const block = await provider.getBlock(receipt.blockNumber);
                const registrationTime = new Date(block.timestamp * 1000).toLocaleString('ru-RU');

                const reportData = {
                    operation: "registration",
                    method: "commit-reveal",
                    contentHash: currentHash,
                    commitBlock: commitBlockNumber,
                    revealBlock: receipt.blockNumber,
                    salt: currentSalt,
                    commitHash: currentCommitHash,
                    registrationDate: registrationTime,
                    blockNumber: receipt.blockNumber,
                    owner: currentUser
                };

                createReport("registration", reportData, receipt);

                const registrationInfo = {
                    status: "✅ SUCCESSFULLY REGISTERED (Commit-Reveal)",
                    contentHash: currentHash,
                    owner: currentUser,
                    registrationDate: registrationTime,
                    transactionHash: receipt.transactionHash,
                    blockNumber: receipt.blockNumber,
                    commitBlock: commitBlockNumber,
                    revealBlock: receipt.blockNumber
                };

                showRegistrationResult(registrationInfo, receipt);
                showNotification('Content successfully registered via Commit-Reveal!', 'success');

                resetCommitRevealState();
                await loadContractInfo();
                if (isOwner) await loadOwnerInfo();

            } catch (error) {
                console.error('Reveal error:', error);
                handleRegistrationError(error);
            } finally {
                document.getElementById('registerLoading').style.display = 'none';
                document.getElementById('revealContent').disabled = false;
            }
        }

        function showCommitInfo(commitOwner, blockNumber) {
            document.getElementById('commitInfo').style.display = 'block';
            document.getElementById('commitDetails').innerHTML = `
                <strong>Commit owner:</strong> ${commitOwner}<br>
                <strong>Commit block:</strong> ${blockNumber}<br>
                <strong>Status:</strong> ✅ Commit successfully completed
            `;

            document.getElementById('registerContent').style.display = 'none';
            document.getElementById('revealContent').style.display = 'block';
        }

        function updateCommitRevealStatus(step) {
            const step1 = document.getElementById('step1');
            const step2 = document.getElementById('step2');

            step1.className = 'status-step';
            step2.className = 'status-step';

            switch (step) {
                case 'commit': step1.className = 'status-step active'; break;
                case 'waiting': 
                    step1.className = 'status-step completed';
                    step2.className = 'status-step active';
                    break;
                case 'reveal':
                    step1.className = 'status-step completed';
                    step2.className = 'status-step completed';
                    break;
            }
        }

        async function startRevealCountdown() {
            updateCommitRevealStatus('waiting');
            document.getElementById('revealCountdown').style.display = 'block';
            document.getElementById('revealContent').disabled = true;

            const revealDelayValue = Number(await contract.revealDelay());

            if (revealDelayValue === 0) {
                document.getElementById('revealContent').disabled = false;
                updateCommitRevealStatus('reveal');
                showNotification('✅ Reveal available immediately — delay = 0', 'success');
                stopRevealCountdown();
                return;
            }

            const secondsToWait = revealDelayValue * 15;
            let timeLeft = secondsToWait;

            commitRevealInterval = setInterval(() => {
                if (timeLeft <= 0) {
                    clearInterval(commitRevealInterval);
                    document.getElementById('revealContent').disabled = false;
                    updateCommitRevealStatus('reveal');
                    showNotification('✅ Waiting time passed — Reveal allowed', 'success');
                    stopRevealCountdown();
                    return;
                }

                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('revealTimer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('blocksRemaining').textContent = Math.ceil(timeLeft / 15);
                document.getElementById('countdownNumber').textContent = Math.ceil(timeLeft / 15);
                timeLeft--;
            }, 1000);
        }

        function stopRevealCountdown() {
            if (commitRevealInterval) {
                clearInterval(commitRevealInterval);
                commitRevealInterval = null;
            }
            document.getElementById('revealCountdown').style.display = 'none';
        }

        function resetCommitRevealState() {
            stopRevealCountdown();
            document.getElementById('revealContent').style.display = 'none';
            document.getElementById('registerContent').style.display = 'block';
            document.getElementById('commitInfo').style.display = 'none';
            document.getElementById('commitRevealStatus').style.display = 'none';

            currentSalt = '';
            currentCommitHash = '';
            commitBlockNumber = 0;
            document.getElementById('saltDisplay').textContent = 'Salt will be generated automatically';
            document.getElementById('commitHashDisplay').textContent = 'Commit hash will be calculated automatically';
            updateCommitRevealStatus('');
        }

        function showRegistrationResult(registrationInfo, receipt) {
            document.getElementById('registerResult').innerHTML = `
                <div class="operation-success">
                    <strong>${registrationInfo.status}</strong><br>
                    <strong>Owner:</strong> ${registrationInfo.owner}<br>
                    <strong>Registration date:</strong> ${registrationInfo.registrationDate}<br>
                    <strong>Content hash:</strong> ${registrationInfo.contentHash}<br>
                    <strong>Transaction:</strong> ${receipt.transactionHash}<br>
                    <strong>Block:</strong> ${receipt.blockNumber}
                    ${registrationInfo.commitBlock ? `<br><strong>Commit block:</strong> ${registrationInfo.commitBlock}` : ''}
                    ${registrationInfo.revealBlock ? `<br><strong>Reveal block:</strong> ${registrationInfo.revealBlock}` : ''}
                    <div class="reminder-note">
                        <h5>💡 Content owner memo</h5>
                        <p>If you lost the report — simply upload your file to the registration panel, get the hash and confirm it in the verification panel.</p>
                    </div>
                </div>
            `;
            document.getElementById('registerResult').className = 'result success';
            document.getElementById('registerResult').style.display = 'block';
            updateReportUI('registerResult');
        }

           function handleRegistrationError(error) {
    console.log('=== ERROR HANDLER START ===');
    console.log('Full error:', error);
    console.log('Error code:', error.code);
    console.log('Error message:', error.message);
    console.log('Error reason:', error.reason);
    console.log('Transaction hash:', error.transactionHash);
    console.log('=== ERROR HANDLER END ===');
    
    let errorMessage = 'Registration error';
    
    if (error.message.includes('ContentAlreadyRegistered')) {
        errorMessage = '❌ Content ALREADY registered in blockchain';
    } else if (error.message.includes('CommitHashAlreadyExist')) {
        errorMessage = '❌ Commit with this hash already exists';
    } else if (error.message.includes('InsufficientFee')) {
        errorMessage = '❌ Insufficient funds for payment';
    } else if (error.message.includes('ContractStopped')) {
        errorMessage = '❌ Contract temporarily stopped by owner';
    } else if (error.message.includes('user rejected') || error.code === 'ACTION_REJECTED') {
        errorMessage = '❌ User rejected transaction in wallet';
    } else if (error.message.includes('status":0')) {
        errorMessage = '❌ Transaction not executed in blockchain (reverted)';
    } else if (error.reason) {
        errorMessage = '❌ Error: ' + error.reason;
    } else {
        errorMessage = '❌ Registration error: ' + error.message;
    }
    
    document.getElementById('registerResult').innerHTML = errorMessage;
    document.getElementById('registerResult').className = 'result error';
    document.getElementById('registerResult').style.display = 'block';
    autoHideError('registerResult');
}
        // ==================== ФУНКЦИИ ВЕРИФИКАЦИИ ====================

       function validateVerifyHash() {
    const hashInput = document.getElementById('verifyHash');
    const hash = hashInput.value.trim();
    const isValid = hash.length === 64 && /^[a-fA-F0-9]{64}$/.test(hash);
    
    const verifyButton = document.getElementById('verifyContent');
    const hintElement = document.getElementById('verifyHashHint');
    
    verifyButton.disabled = !isValid;
    
    // Показывать подсказку если хэш введен вручную
    if (hash.length > 0 && hash.length !== 64) {
        if (hintElement) hintElement.style.display = 'block';
    } else {
        if (hintElement) hintElement.style.display = 'none';
    }
    
    return isValid;
}

        async function verifyContent() {
            if (!validateVerifyHash()) {
                showNotification('Enter valid hash for verification', 'error');
                return;
            }
            
            if (!contract) {
                showNotification('Contract not initialized', 'error');
                return;
            }

            if (!isOwner && !userAgreed) {
                showNotification('❌ To perform this operation, you need to accept the user agreement', 'error');
                return;
            }

            try {
                document.getElementById('verifyLoading').style.display = 'block';
                document.getElementById('verifyContent').disabled = true;
                
                const hash = document.getElementById('verifyHash').value.trim();
                const contentHashBytes32 = hexToBytes32(hash);
                const verificationFee = await contract.verificationFee();
                
                const result = await contract.callStatic.verifyContent(contentHashBytes32, {
                    value: verificationFee
                });
                
                const tx = await contract.verifyContent(contentHashBytes32, {
                    value: verificationFee,
                    gasLimit: getGasLimit('VERIFY')
                });
                
                showNotification('Registration verification...', 'info');
                
                const receipt = await tx.wait();
                
                const [exists, registrant, originalRegistrant, timestamp, transferCount, lastTransferTime] = result;
                
               const reportData = {
                   operation: "verification",
                   contentHash: hash,
                   exists: exists,
                   registrant: registrant,
                   originalRegistrant: originalRegistrant,  
                   timestamp: timestamp,
                   transferCount: transferCount,
                   lastTransferTime: lastTransferTime
                };
                
                createReport("verification", reportData, receipt);
                
                showVerificationResult(hash, exists, registrant, originalRegistrant, timestamp, transferCount, lastTransferTime, receipt);
                showNotification('Verification completed!', 'success');
                
                await loadContractInfo();
                if (isOwner) await loadOwnerInfo();
                
            } catch (error) {
                console.error('Verification error:', error);
                handleVerificationError(error);
            } finally {
                document.getElementById('verifyLoading').style.display = 'none';
                document.getElementById('verifyContent').disabled = false;
            }
        }

        function showVerificationResult(hash, exists, registrant, originalRegistrant, timestamp, transferCount, lastTransferTime, receipt) {
    
          const originalRegistrationDate = exists && timestamp > 1000000000 ? 
          new Date(timestamp * 1000).toLocaleString('ru-RU') : 
          'Unknown';
    
          const lastTransferDate = lastTransferTime > 1000000000 ? 
          new Date(lastTransferTime * 1000).toLocaleString('ru-RU') : 
          'Not transferred';

          const verificationInfo = {
          status: exists ? "✅ SUCCESSFULLY VERIFIED" : "❌ NOT REGISTERED",
          contentHash: hash,
          exists: exists,
          registrant: registrant,
          originalRegistrant: originalRegistrant,
          originalRegistrationDate: originalRegistrationDate, 
          lastTransferDate: lastTransferDate,       
          transferCount: transferCount.toString(),
          network: currentNetwork.name,
     };
    
    document.getElementById('verifyResult').innerHTML = `
        <div class="operation-success">
            <strong>${verificationInfo.status}</strong><br>
            ${exists ? `
                <strong>Owner:</strong> ${verificationInfo.registrant}<br>
                <strong>Owner address:</strong> <span class="address">${verificationInfo.registrant}</span><br>
                <strong>Original registrant:</strong> <span class="address">${verificationInfo.originalRegistrant}</span><br>
                <strong>First registration date:</strong> ${verificationInfo.originalRegistrationDate}<br>
                <strong>Last transfer date:</strong> ${verificationInfo.lastTransferDate}<br>
                <strong>Content hash:</strong> <span class="hash">${verificationInfo.contentHash}</span><br>
                <strong>Rights transfer count:</strong> ${verificationInfo.transferCount}
            ` : `
                <strong>Content hash:</strong> <span class="hash">${verificationInfo.contentHash}</span><br>
                Content with specified hash is not registered in the system.
            `}
            
            <div class="reminder-note">
                <h5>💡 Content owner memo</h5>
                <p>If you as content owner lost or didn't manage to download or copy for any reason any report - you can always as content owner upload it again in registration panel and get the hash, copy it and go to verification panel and paste it in input field and verify getting a new report.</p>
            </div>
        </div>
    `;
    document.getElementById('verifyResult').className = exists ? 'result success' : 'result error';
    document.getElementById('verifyResult').style.display = 'block';
    
    updateReportUI('verifyResult');
}  

        function handleVerificationError(error) {
            let errorMessage = 'Verification error';
            
            if (error.message.includes('InsufficientFee')) {
                errorMessage = '❌ Insufficient funds for verification payment';
            } else if (error.message.includes('ContractStopped')) {
                errorMessage = '❌ Contract temporarily stopped';
            } else if (error.message.includes('user rejected')) {
                errorMessage = '❌ User rejected transaction';
            } else if (error.message.includes('execution reverted')) {
                errorMessage = '❌ Contract execution error';
            } else {
                errorMessage = '❌ Verification error: ' + error.message;
            }
            
            document.getElementById('verifyResult').innerHTML = errorMessage;
            document.getElementById('verifyResult').className = 'result error';
            document.getElementById('verifyResult').style.display = 'block';
            autoHideError('verifyResult');
        }

        // ==================== ФУНКЦИИ ПЕРЕДАЧИ ПРАВ ====================

        async function validateTransferFields() {
            const hash = document.getElementById('transferHash').value.trim();
            const address = document.getElementById('newOwnerAddress').value.trim();
            
            const isHashValid = hash.length === 64 && /^[a-fA-F0-9]{64}$/.test(hash);
            const isAddressValid = /^0x[a-fA-F0-9]{40}$/.test(address);
            
            let isNotSelfTransfer = true;
            let validationMessage = '';
            
            if (isAddressValid && currentUserAddress) {
                if (address.toLowerCase() === currentUserAddress.toLowerCase()) {
                    isNotSelfTransfer = false;
                    validationMessage = '❌ Cannot transfer rights to yourself';
                }
            }
            
            const validationElement = document.getElementById('newOwnerAddressValidation');
            if (validationElement) {
                if (!isNotSelfTransfer) {
                    validationElement.textContent = validationMessage;
                    validationElement.className = 'validation-message validation-error';
                    validationElement.style.display = 'block';
                    setTimeout(() => validationElement.style.display = 'none', 5000);
                } else {
                    validationElement.style.display = 'none';
                }
            }
            
            const isValid = isHashValid && isAddressValid && isNotSelfTransfer;
            document.getElementById('transferOwnership').disabled = !isValid;
            return isValid;
        }
        async function transferOwnership() {
    if (!validateTransferFields()) {
        showNotification('Check the correctness of entered data', 'error');
        return;
    }
    
    if (!contract) {
        showNotification('Contract not initialized', 'error');
        return;
    }

    if (!isOwner && !userAgreed) {
        showNotification('❌ To perform this operation, you need to accept the user agreement', 'error');
        return;
    }

    try {
        document.getElementById('transferLoading').style.display = 'block';
        document.getElementById('transferOwnership').disabled = true;
        
        const hash = document.getElementById('transferHash').value.trim();
        const newOwner = document.getElementById('newOwnerAddress').value.trim();
        const contentHashBytes32 = hexToBytes32(hash);
        const transferFee = await contract.transferFee();
        
        await contract.callStatic.transferContentOwnership(contentHashBytes32, newOwner, {
            value: transferFee
        });
        
        const tx = await contract.transferContentOwnership(contentHashBytes32, newOwner, {
            value: transferFee,
            gasLimit: getGasLimit('TRANSFER')
        });
        
        showNotification('Rights transfer...', 'info');
        
        const receipt = await tx.wait();
        
        // ПОЛУЧАЕМ АКТУАЛЬНЫЕ ДАННЫЕ ИЗ КОНТРАКТА ПОСЛЕ ПЕРЕДАЧИ
        const contentInfo = await contract.registrations(contentHashBytes32);
        
        // ПРАВИЛЬНО ФОРМАТИРУЕМ ДАТЫ В ФОРМАТЕ число/месяц/год
        const originalRegistrationDate = formatDate(new Date(contentInfo.timestamp * 1000));
        const lastTransferDate = formatDate(new Date(contentInfo.lastTransferTime * 1000));

        const reportData = {
            operation: "transfer",
            contentHash: hash,
            previousOwner: currentUserAddress,
            newOwner: newOwner,
            transferDate: lastTransferDate,  // УЖЕ ОТФОРМАТИРОВАННАЯ ДАТА
            originalRegistrationDate: originalRegistrationDate,
            originalRegistrant: contentInfo.originalRegistrant
        };
        
        createReport("transfer", reportData, receipt);
        
        showTransferResult(hash, newOwner, receipt, reportData);
        showNotification('Rights successfully transferred!', 'success');
        
        await loadContractInfo();
        if (isOwner) await loadOwnerInfo();
        
    } catch (error) {
        console.error('Rights transfer error:', error);
        handleTransferError(error);
    } finally {
        document.getElementById('transferLoading').style.display = 'none';
        document.getElementById('transferOwnership').disabled = false;
    }
}

function showTransferResult(hash, newOwner, receipt, reportData) {
    const transferInfo = {
        status: "✅ RIGHTS SUCCESSFULLY TRANSFERRED",
        contentHash: hash,
        previousOwner: currentUserAddress,
        newOwner: newOwner,
        transferDate: reportData.transferDate,  // ИСПОЛЬЗУЕМ ИЗ REPORT DATA
        originalRegistrationDate: reportData.originalRegistrationDate,
        originalRegistrant: reportData.originalRegistrant,
        transactionHash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        network: currentNetwork.name
    };
    
    document.getElementById('transferResult').innerHTML = `
        <div class="operation-success">
            <strong>${transferInfo.status}</strong><br>
            <strong>Content hash:</strong> <span class="hash">${transferInfo.contentHash}</span><br>
            <strong>Previous owner:</strong> <span class="address">${transferInfo.previousOwner}</span><br>
            <strong>New owner:</strong> <span class="address">${transferInfo.newOwner}</span><br>
            <strong>Transfer date:</strong> ${transferInfo.transferDate}<br>
            <strong>First registration date:</strong> ${transferInfo.originalRegistrationDate || 'Unknown'}<br>
            <strong>Original registrant:</strong> ${transferInfo.originalRegistrant || 'Unknown'}<br>
            <strong>Transaction:</strong> <span class="tx-hash">${transferInfo.transactionHash}</span><br>
            <strong>Block:</strong> ${transferInfo.blockNumber}<br>
            <strong>Network:</strong> ${transferInfo.network}
            
            <div class="security-warning" style="margin-top: 15px;">
                <strong>⚠️ Attention:</strong> You are no longer the owner of this content. 
                Rights transfer operation is irreversible.
            </div>
            
            <div class="reminder-note">
                <h5>💡 Content owner memo</h5>
                <p>If you as content owner lost or didn't manage to download or copy for any reason any report - you can always as content owner upload it again in registration panel and get the hash, copy it and go to verification panel and paste it in input field and verify getting a new report.</p>
            </div>
        </div>
    `;
    document.getElementById('transferResult').className = 'result success';
    document.getElementById('transferResult').style.display = 'block';
    
    updateReportUI('transferResult');
}

        function handleTransferError(error) {
            let errorMessage = 'Rights transfer error';
            
            if (error.message.includes('ContentNotRegistered') || error.message.includes('status":0')) {
                errorMessage = '❌ Content not registered';
            } else if (error.message.includes('NotContentOwner')) {
                errorMessage = '❌ You are not the owner of this content';
            } else if (error.message.includes('InsufficientFee')) {
                errorMessage = '❌ Insufficient funds for transfer payment';
            } else if (error.message.includes('ContractStopped')) {
                errorMessage = '❌ Contract temporarily stopped';
            } else if (error.message.includes('user rejected')) {
                errorMessage = '❌ User rejected transaction';
            } else if (error.message.includes('InvalidAddress')) {
                errorMessage = '❌ Invalid new owner address';
            } else if (error.message.includes('ContractAddressNotAllowed')) {
                errorMessage = '❌ Cannot transfer rights to contract address';
            } else {
                errorMessage = '❌ Rights transfer error: ' + error.message;
            }
            
            document.getElementById('transferResult').innerHTML = errorMessage;
            document.getElementById('transferResult').className = 'result error';
            document.getElementById('transferResult').style.display = 'block';
            autoHideError('transferResult');
        }

        // ==================== ФУНКЦИИ ВЛАДЕЛЬЦА ====================

        async function setRegistrationMode(mode) {
            if (!contract || !isOwner) {
                showNotification('Only owner can change modes', 'error');
                return;
            }
            
            try {
                document.getElementById('modeLoading').style.display = 'block';
                
                const tx = await contract.setRegistrationMode(mode);
                showNotification('Updating registration mode...', 'info');
                
                const receipt = await tx.wait();
                
                currentRegistrationMode = mode;
                updateRegistrationModeUI(mode);
                showNotification('Registration mode successfully updated!', 'success');
                
            } catch (error) {
                console.error('Mode update error:', error);
                handleOwnerError(error);
            } finally {
                document.getElementById('modeLoading').style.display = 'none';
            }
        }

        function updateRegistrationModeUI(mode) {
            const modeStatus = document.getElementById('currentModeStatus');
            const modeButtons = document.querySelectorAll('.mode-btn');
            
            modeButtons.forEach(btn => {
                btn.classList.remove('active', 'disabled');
                if (parseInt(btn.getAttribute('data-mode')) === mode) btn.classList.add('active');
            });
            
            switch(mode) {
                case 0: modeStatus.textContent = 'BOTH REGISTRATIONS (Basic + Commit-Reveal)'; break;
                case 1: modeStatus.textContent = 'BASIC REGISTRATION ONLY'; break;
                case 2: modeStatus.textContent = 'COMMIT-REVEAL ONLY'; break;
                case 3: modeStatus.textContent = 'ALL REGISTRATIONS DISABLED'; break;
            }
            
            updateRegistrationMethodButtons();
        }

        async function updateAllFees() {
            if (!contract || !isOwner) {
                showNotification('Only owner can change rates', 'error');
                return;
            }
            
            const newRegistrationFee = document.getElementById('newRegistrationFee').value;
            const newCommitFee = document.getElementById('newCommitFee').value;
            const newRevealFee = document.getElementById('newRevealFee').value;
            const newVerificationFee = document.getElementById('newVerificationFee').value;
            const newTransferFee = document.getElementById('newTransferFee').value;
            const newRevealDelay = document.getElementById('newRevealDelay').value;
            
            if (!newRegistrationFee && !newCommitFee && !newRevealFee && !newVerificationFee && !newTransferFee && !newRevealDelay) {
                showNotification('Enter at least one value for update', 'error');
                return;
            }
            
            try {
                document.getElementById('updateFeesLoading').style.display = 'block';
                
                const [currentBasicFee, currentCommitFee, currentRevealFee, currentVerificationFee, currentTransferFee, currentDelay] = await contract.getAllFeesAndDelay();
                
                const basicFee = newRegistrationFee ? ethers.BigNumber.from(newRegistrationFee) : currentBasicFee;
                const commitFee = newCommitFee ? ethers.BigNumber.from(newCommitFee) : currentCommitFee;
                const revealFee = newRevealFee ? ethers.BigNumber.from(newRevealFee) : currentRevealFee;
                const verificationFee = newVerificationFee ? ethers.BigNumber.from(newVerificationFee) : currentVerificationFee;
                const transferFee = newTransferFee ? ethers.BigNumber.from(newTransferFee) : currentTransferFee;
                const delay = newRevealDelay ? parseInt(newRevealDelay) : currentDelay;
                
                const tx = await contract.updateFeesAndDelay(
                    basicFee, commitFee, revealFee, verificationFee, transferFee, delay
                );
                
                showNotification('Updating rates...', 'info');
                
                const receipt = await tx.wait();
                
                document.getElementById('newRegistrationFee').value = '';
                document.getElementById('newCommitFee').value = '';
                document.getElementById('newRevealFee').value = '';
                document.getElementById('newVerificationFee').value = '';
                document.getElementById('newTransferFee').value = '';
                document.getElementById('newRevealDelay').value = '';
                
                showNotification('Rates successfully updated!', 'success');
                
                await loadContractInfo();
                await loadOwnerInfo();
                
            } catch (error) {
                console.error('Rates update error:', error);
                handleOwnerError(error);
            } finally {
                document.getElementById('updateFeesLoading').style.display = 'none';
            }
        }

        async function withdrawFees() {
            if (!contract || !isOwner) {
                showNotification('Only owner can withdraw funds', 'error');
                return;
            }
            
            const withdrawAmount = document.getElementById('withdrawAmount').value.trim();
            
            if (!withdrawAmount) {
                showNotification('Enter amount to withdraw', 'error');
                return;
            }
            
            try {
                document.getElementById('withdrawLoading').style.display = 'block';
                
                const amount = ethers.BigNumber.from(withdrawAmount);
                
                const tx = await contract.withdrawBalance(amount);
                
                showNotification('Withdrawing funds...', 'info');
                
                const receipt = await tx.wait();
                
                document.getElementById('withdrawAmount').value = '';
                
                showNotification(`Funds successfully withdrawn!`, 'success');
                
                await loadOwnerInfo();
                
            } catch (error) {
                console.error('Withdrawal error:', error);
                handleOwnerError(error);
            } finally {
                document.getElementById('withdrawLoading').style.display = 'none';
            }
        }

       async function stopContract() {
    if (!contract || !isOwner) {
        showNotification('Only owner can stop contract', 'error');
        return;
    }
    
    try {
        const tx = await contract.stopContract();
        showNotification('Stopping contract...', 'info');
        
        const receipt = await tx.wait();
        console.log('Stop contract receipt:', receipt);
        
        // Принудительно обновляем статус после остановки
        updateContractStatus(false, false);
        showNotification('Contract successfully stopped!', 'success');
        
    } catch (error) {
        console.error('Contract stop error:', error);
        handleOwnerError(error);
    }
}
       async function activateContract() {
    if (!contract || !isOwner) {
        showNotification('Only owner can activate contract', 'error');
        return;
    }
    
    try {
        const tx = await contract.activateContract();
        showNotification('Activating contract...', 'info');
        
        const receipt = await tx.wait();
        console.log('Activate contract receipt:', receipt);
        
        // Принудительно обновляем статус после активации
        updateContractStatus(true, false);
        showNotification('Contract successfully activated!', 'success');
        
    } catch (error) {
        console.error('Contract activation error:', error);
        handleOwnerError(error);
    }
}

        // ==================== НОВАЯ ФУНКЦИЯ: ПЕРЕДАЧА ВЛАДЕНИЯ КОНТРАКТОМ ====================

        async function validateContractTransferFields() {
            const address = document.getElementById('newContractOwnerAddress').value.trim();
            const isAddressValid = /^0x[a-fA-F0-9]{40}$/.test(address);
            
            let isNotSelfTransfer = true;
            let validationMessage = '';
            
            if (isAddressValid && currentUserAddress) {
                if (address.toLowerCase() === currentUserAddress.toLowerCase()) {
                    isNotSelfTransfer = false;
                    validationMessage = '❌ Cannot transfer contract to yourself';
                }
            }
            
            const validationElement = document.getElementById('newContractOwnerAddressValidation');
            if (validationElement) {
                if (!isNotSelfTransfer) {
                    validationElement.textContent = validationMessage;
                    validationElement.className = 'validation-message validation-error';
                    validationElement.style.display = 'block';
                    setTimeout(() => validationElement.style.display = 'none', 5000);
                } else {
                    validationElement.style.display = 'none';
                }
            }
            
            const isValid = isAddressValid && isNotSelfTransfer;
            document.getElementById('transferContractOwnership').disabled = !isValid;
            return isValid;
        }

        async function transferContractOwnership() {
            if (!validateContractTransferFields()) {
                showNotification('Check the correctness of entered address', 'error');
                return;
            }
            
            if (!contract || !isOwner) {
                showNotification('Only owner can transfer contract ownership', 'error');
                return;
            }

            const newOwner = document.getElementById('newContractOwnerAddress').value.trim();
            
            // Дополнительная проверка - предупреждение пользователя
            const confirmTransfer = confirm(
                '🚨 CRITICAL WARNING:\n\n' +
                'You are about to transfer contract ownership to address:\n' + newOwner + '\n\n' +
                'After confirming this operation:\n' +
                '• You WILL LOSE all contract management rights\n' +
                '• You will no longer be able to change rates\n' +
                '• You will no longer be able to stop/activate contract\n' +
                '• You will no longer be able to withdraw funds\n' +
                '• Operation is IRREVERSIBLE\n\n' +
                'Are you sure you want to continue?'
            );
            
            if (!confirmTransfer) {
                showNotification('Ownership transfer canceled', 'info');
                return;
            }

            try {
                document.getElementById('transferContractLoading').style.display = 'block';
                document.getElementById('transferContractOwnership').disabled = true;
                
                // Проверяем, что адрес валиден и не является контрактом
                const code = await provider.getCode(newOwner);
                if (code !== '0x') {
                    showNotification('❌ Cannot transfer ownership to contract address', 'error');
                    return;
                }
                
                const tx = await contract.transferContractOwnership(newOwner);
                
                showNotification('🚨 Transferring contract ownership...', 'info');
                
                const receipt = await tx.wait();
                
                const reportData = {
                    operation: "contract_transfer",
                    previousOwner: currentUserAddress,
                    newOwner: newOwner,
                    transactionHash: receipt.transactionHash,
                    blockNumber: receipt.blockNumber,
                    network: currentNetwork.name
                };
                
                createReport("contract_transfer", reportData, receipt);
                
                document.getElementById('transferContractResult').innerHTML = `
                    <div class="operation-success">
                        <strong>🚨 CONTRACT OWNERSHIP TRANSFERRED</strong><br>
                        <strong>Previous owner:</strong> <span class="address">${currentUserAddress}</span><br>
                        <strong>New owner:</strong> <span class="address">${newOwner}</span><br>
                        <strong>Transaction:</strong> <span class="tx-hash">${receipt.transactionHash}</span><br>
                        <strong>Block:</strong> ${receipt.blockNumber}<br>
                        <strong>Network:</strong> ${currentNetwork.name}
                        
                        <div class="security-warning" style="margin-top: 15px; background: #FEE2E2; border-color: #EF4444;">
                            <strong>⚠️ IMPORTANT:</strong> You are no longer the owner of this contract. 
                            All management rights have been transferred to the new owner. Operation is irreversible.
                        </div>
                    </div>
                `;
                document.getElementById('transferContractResult').className = 'result success';
                document.getElementById('transferContractResult').style.display = 'block';
                
                showNotification('🚨 Contract ownership successfully transferred!', 'success');
                
                // Обновляем интерфейс - пользователь больше не владелец
                isOwner = false;
                updateUserInterface();
                
            } catch (error) {
                console.error('Contract ownership transfer error:', error);
                handleContractTransferError(error);
            } finally {
                document.getElementById('transferContractLoading').style.display = 'none';
                document.getElementById('transferContractOwnership').disabled = false;
            }
        }

        function handleContractTransferError(error) {
            let errorMessage = 'Contract ownership transfer error';
            
            if (error.message.includes('InvalidAddress')) {
                errorMessage = '❌ Invalid new owner address';
            } else if (error.message.includes('ContractAddressNotAllowed')) {
                errorMessage = '❌ Cannot transfer ownership to contract address';
            } else if (error.message.includes('user rejected')) {
                errorMessage = '❌ User rejected transaction';
            } else if (error.message.includes('NotContractOwner')) {
                errorMessage = '❌ Only owner can transfer contract';
            } else {
                errorMessage = '❌ Ownership transfer error: ' + error.message;
            }
            
            document.getElementById('transferContractResult').innerHTML = errorMessage;
            document.getElementById('transferContractResult').className = 'result error';
            document.getElementById('transferContractResult').style.display = 'block';
            autoHideError('transferContractResult');
        }

        function handleOwnerError(error) {
            if (error.message.includes('user rejected')) {
                showNotification('User rejected transaction', 'error');
            } else {
                showNotification('Error: ' + error.message, 'error');
            }
        }

        // ==================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ====================

     function setupClearButtons() {
    const clearButtons = [
        { input: 'verifyHash', button: 'clearVerifyHash' },
        { input: 'transferHash', button: 'clearTransferHash' },
        { input: 'newOwnerAddress', button: 'clearNewOwner' },
        { input: 'newContractOwnerAddress', button: 'clearNewContractOwner' },
        { input: 'withdrawAmount', button: 'clearWithdrawAmount' },
        { input: 'newRegistrationFee', button: 'clearRegistrationFee' },
        { input: 'newCommitFee', button: 'clearCommitFee' },
        { input: 'newRevealFee', button: 'clearRevealFee' },
        { input: 'newVerificationFee', button: 'clearVerificationFee' },
        { input: 'newTransferFee', button: 'clearTransferFee' },
        { input: 'newRevealDelay', button: 'clearRevealDelay' }
    ];
    
    clearButtons.forEach(pair => {
        const input = document.getElementById(pair.input);
        const button = document.getElementById(pair.button);
        
        if (input && button) {
            // Показывать/скрывать кнопку очистки
            input.addEventListener('input', function() {
                button.style.display = this.value ? 'block' : 'none';
                
                // Автоматическая валидация при вводе
                if (pair.input === 'verifyHash') validateVerifyHash();
                if (pair.input === 'transferHash' || pair.input === 'newOwnerAddress') validateTransferFields();
                if (pair.input === 'newContractOwnerAddress') validateContractTransferFields();
            });
            
            // Очистка поля
            button.addEventListener('click', function() {
                input.value = '';
                button.style.display = 'none';
                
                // Сброс валидации
                if (pair.input === 'verifyHash') {
                    document.getElementById('verifyContent').disabled = true;
                }
                if (pair.input === 'transferHash' || pair.input === 'newOwnerAddress') {
                    document.getElementById('transferOwnership').disabled = true;
                }
                if (pair.input === 'newContractOwnerAddress') {
                    document.getElementById('transferContractOwnership').disabled = true;
                }
                
                // Скрыть подсказку
                const hintId = pair.input + 'Hint';
                const hintElement = document.getElementById(hintId);
                if (hintElement) hintElement.style.display = 'none';
            });
        }
    });
}
        function showInputHint(hintId, value) {
            const hintElement = document.getElementById(hintId);
            if (hintElement) {
                if (value && value.length > 0) {
                    hintElement.style.display = 'block';
                    if ((hintId.includes('Hash') && value.length === 64) || 
                        (hintId.includes('Address') && /^0x[a-fA-F0-9]{40}$/.test(value))) {
                        setTimeout(() => hintElement.style.display = 'none', 5000);
                    }
                } else {
                    hintElement.style.display = 'none';
                }
            }
        }

        function updateRegistrationUI() {
            const saltGroup = document.getElementById('saltGroup');
            const commitHashGroup = document.getElementById('commitHashGroup');
            const commitRevealStatus = document.getElementById('commitRevealStatus');
            const revealContentBtn = document.getElementById('revealContent');
            const registerContentBtn = document.getElementById('registerContent');

            const availability = checkRegistrationAvailability();
            
            if (currentProtection === 'COMMIT_REVEAL') {
                saltGroup.style.display = 'block';
                commitHashGroup.style.display = 'block';
                commitRevealStatus.style.display = 'block';
                revealContentBtn.style.display = 'none';
                registerContentBtn.style.display = 'block';
                registerContentBtn.textContent = currentLanguage === 'ru' ? 'Выполнить Commit' : 'Perform Commit';
                
                if (!availability.commit) {
                    registerContentBtn.disabled = true;
                    registerContentBtn.title = 'Registration via Commit-Reveal temporarily disabled';
                } else {
                    registerContentBtn.disabled = !currentHash;
                    registerContentBtn.title = '';
                }
                
                generateSalt();
            } else {
                saltGroup.style.display = 'none';
                commitHashGroup.style.display = 'none';
                commitRevealStatus.style.display = 'none';
                revealContentBtn.style.display = 'none';
                registerContentBtn.style.display = 'block';
                registerContentBtn.textContent = 'Register Content';
                
                if (!availability.basic) {
                    registerContentBtn.disabled = true;
                    registerContentBtn.title = 'Basic registration temporarily disabled';
                } else {
                    registerContentBtn.disabled = !currentHash;
                    registerContentBtn.title = '';
                }
            }
            
            updateRegistrationMethodButtons();
        }

        function checkRegistrationAvailability() {
            switch(currentRegistrationMode) {
                case 0: return { basic: true, commit: true };
                case 1: return { basic: true, commit: false };
                case 2: return { basic: false, commit: true };
                case 3: return { basic: false, commit: false };
                default: return { basic: true, commit: true };
            }
        }

        function updateRegistrationMethodButtons() {
            const availability = checkRegistrationAvailability();
            const basicOption = document.querySelector('[data-protection="BASIC"]');
            const commitOption = document.querySelector('[data-protection="COMMIT_REVEAL"]');
            const warningElement = document.getElementById('registrationMethodWarning');
            const warningMessage = document.getElementById('registrationMethodMessage');
            
            basicOption.classList.remove('disabled');
            commitOption.classList.remove('disabled');
            warningElement.style.display = 'none';
            
            if (!availability.basic && !availability.commit) {
                basicOption.classList.add('disabled');
                commitOption.classList.add('disabled');
                warningMessage.textContent = 'All registration methods temporarily disabled by contract owner.';
                warningElement.style.display = 'block';
                setTimeout(() => warningElement.style.display = 'none', 5000);
            } else if (!availability.basic) {
                basicOption.classList.add('disabled');
                warningMessage.textContent = 'Basic registration temporarily disabled by contract owner.';
                warningElement.style.display = 'block';
                if (currentProtection === 'BASIC') commitOption.click();
                setTimeout(() => warningElement.style.display = 'none', 5000);
            } else if (!availability.commit) {
                commitOption.classList.add('disabled');
                warningMessage.textContent = 'Registration via Commit-Reveal temporarily disabled by contract owner.';
                warningElement.style.display = 'block';
                if (currentProtection === 'COMMIT_REVEAL') basicOption.click();
                setTimeout(() => warningElement.style.display = 'none', 5000);
            }
        }

        async function checkAndShowContentNotRegistered(hashInputId, resultElementId) {
            const hash = document.getElementById(hashInputId).value.trim();
            if (hash.length === 64) {
                const exists = await checkContentExists(hash);
                if (!exists) {
                    const resultElement = document.getElementById(resultElementId);
                    resultElement.innerHTML = '❌ Content not registered';
                    resultElement.className = 'result error';
                    resultElement.style.display = 'block';
                    autoHideError(resultElementId);
                }
            }
        }

        function generateSalt() {
            const array = new Uint8Array(32);
            window.crypto.getRandomValues(array);
            currentSalt = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            document.getElementById('saltDisplay').textContent = currentSalt;
            
            if (currentHash && currentUserAddress) updateCommitHash();
        }

        function updateCommitHash() {
            if (currentHash && currentSalt && currentUserAddress) {
                const commitData = currentHash + currentSalt + currentUserAddress.toLowerCase().slice(2);
                currentCommitHash = ethers.utils.keccak256('0x' + commitData);
                document.getElementById('commitHashDisplay').textContent = currentCommitHash;
            }
        }

        function toggleHashVisibility() {
            const hashDisplay = document.getElementById('contentHashDisplay');
            const toggleButton = document.getElementById('toggleHash');
            
            if (isHashVisible) {
                hashDisplay.classList.remove('hash-visible');
                hashDisplay.classList.add('hash-masked');
                toggleButton.textContent = 'Show hash';
                isHashVisible = false;
            } else {
                hashDisplay.classList.remove('hash-masked');
                hashDisplay.classList.add('hash-visible');
                toggleButton.textContent = 'Hide hash';
                isHashVisible = true;
            }
        }

        function copyHashToClipboard() {
            if (!currentHash) {
                showNotification('No hash to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(currentHash).then(() => {
                showNotification('Hash copied to clipboard!', 'success');
            }).catch(err => {
                const textArea = document.createElement('textarea');
                textArea.value = currentHash;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('Hash copied to clipboard!', 'success');
            });
        }

        function autoHideError(elementId) {
            setTimeout(() => {
                const element = document.getElementById(elementId);
                if (element && element.classList.contains('error')) element.style.display = 'none';
            }, 5000);
        }

        // ==================== ФУНКЦИИ РАБОТЫ С КОНТРАКТОМ ====================

        async function loadContractInfo() {
            if (!contract) return;
            
            try {
                const [basicRegistrationFee, commitFee, revealFee, verificationFee, transferFee, revealDelayValue] = await contract.getAllFeesAndDelay();
                revealDelay = revealDelayValue.toNumber();
                
                // Создаем текст комиссии в зависимости от языка
const feeText = currentLanguage === 'ru' ? 'Комиссия: ' : 'Fee: ';

document.getElementById('basicFeeDisplay').textContent = `${feeText}${ethers.utils.formatEther(basicRegistrationFee)} ${currentNetwork.currency}`;
document.getElementById('commitRevealFeeDisplay').textContent = `${feeText}${ethers.utils.formatEther(commitFee)} + ${ethers.utils.formatEther(revealFee)} ${currentNetwork.currency}`;
document.getElementById('verificationFeeDisplay').textContent = `${ethers.utils.formatEther(verificationFee)} ${currentNetwork.currency}`;
document.getElementById('transferFeeDisplay').textContent = `${ethers.utils.formatEther(transferFee)} ${currentNetwork.currency}`;
                const mode = await contract.getRegistrationMode();
                currentRegistrationMode = mode;
                updateRegistrationModeUI(mode);
                
            } catch (error) {
                showNotification('Contract information loading error: ' + error.message, 'error');
            }
        }

        async function loadOwnerInfo() {
            if (!isOwner || !contract || !signer) return;
            
            try {
                const contractBalance = await contract.getContractBalance();
                const [basicRegistrationFee, commitFee, revealFee, verificationFee, transferFee, currentDelay] = await contract.getAllFeesAndDelay();
                const walletBalance = await provider.getBalance(await signer.getAddress());
                const contractStats = await contract.getContractStats();
                
                document.getElementById('ownerContractBalance').textContent = ethers.utils.formatEther(contractBalance).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerWalletBalance').textContent = ethers.utils.formatEther(walletBalance).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerRegistrationFee').textContent = ethers.utils.formatEther(basicRegistrationFee).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerCommitFee').textContent = ethers.utils.formatEther(commitFee).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerRevealFee').textContent = ethers.utils.formatEther(revealFee).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerVerificationFee').textContent = ethers.utils.formatEther(verificationFee).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerTransferFee').textContent = ethers.utils.formatEther(transferFee).substring(0, 8) + ' ' + currentNetwork.currency;
                document.getElementById('ownerRevealDelay').textContent = currentDelay.toString();
                document.getElementById('ownerTotalRegistered').textContent = contractStats[0].toString();
                document.getElementById('ownerTotalVerifications').textContent = contractStats[1].toString();
                document.getElementById('ownerTotalTransfers').textContent = contractStats[2].toString();
                
            } catch (error) {
                console.log('Owner information loading error:', error);
            }
        }
     async function checkContractState() {
    if (!contract) {
        console.log('Contract not initialized');
        updateContractStatus(false, true); // unknown
        return;
    }
    
    try {
        const state = await contract.state();
        console.log('Contract state:', state);
        console.log('Contract state type:', typeof state);
        
        // state возвращается как обычное число - просто сравниваем
        const isActive = state === 0;
        
        console.log('Contract is active:', isActive);
        updateContractStatus(isActive, false);
        
    } catch (error) {
        console.log('Contract state check error:', error);
        updateContractStatus(false, true);
    }
}

      function updateContractStatus(isActive, isUnknown) {
    const statusElement = document.getElementById('contractStatus');
    const stoppedMessage = document.getElementById('contractStoppedMessage');
    
    console.log('updateContractStatus called:', { isActive, isUnknown });
    
    // СОХРАНИМ ТЕКУЩЕЕ СОСТОЯНИЕ В ГЛОБАЛЬНУЮ ПЕРЕМЕННУЮ
    window.lastContractStatus = { isActive, isUnknown };
    
    if (isUnknown) {
        statusElement.textContent = getTranslation('contractStatusUnknown');
        statusElement.className = 'contract-status';
        if (stoppedMessage) stoppedMessage.style.display = 'none';
        console.log('Setting status to UNKNOWN');
    } else if (isActive) {
        statusElement.textContent = getTranslation('contractStatusActive');
        statusElement.className = 'contract-status active';
        if (stoppedMessage) stoppedMessage.style.display = 'none';
        console.log('Setting status to ACTIVE');
    } else {
        statusElement.textContent = getTranslation('contractStatusInactive');
        statusElement.className = 'contract-status';
        if (stoppedMessage) stoppedMessage.style.display = 'block';
        console.log('Setting status to INACTIVE');
    }
    
    console.log('Final status text:', statusElement.textContent);
    console.log('Final status class:', statusElement.className);
}
   
        async function checkIfOwner() {
            if (!contract || !signer) return;
            
            try {
                ownerAddress = await contract.owner();
                const userAddress = await signer.getAddress();
                
                isOwner = (userAddress.toLowerCase() === ownerAddress.toLowerCase());
                
                // Обновляем состояние пользовательского соглашения
                checkUserAgreement();
                
                if (isOwner) {
                    showNotification('Contract owner account detected', 'success');
                    await loadOwnerInfo();
                }
            } catch (error) {
                console.log('Owner check error:', error);
                isOwner = false;
                checkUserAgreement();
            }
        }

        async function checkContentExists(hash) {
            if (!contract || !hash || hash.length !== 64) return false;
            
            try {
                const contentHashBytes32 = hexToBytes32(hash);
                const registration = await contract.registrations(contentHashBytes32);
                return registration.timestamp > 0;
            } catch (error) {
                console.log('Content check error:', error);
                return false;
            }
        }

        // ==================== ФУНКЦИИ ОТЧЕТОВ ====================

        function formatReportAsText(report) {
            let text = '';
            
            switch(report.type) {
                case 'registration': text = formatRegistrationReport(report); break;
                case 'verification': text = formatVerificationReport(report); break;
                case 'transfer': text = formatTransferReport(report); break;
                case 'contract_transfer': text = formatContractTransferReport(report); break;
                default: text = JSON.stringify(report, null, 2);
            }
            
            return text;
        }

        function formatRegistrationReport(report) {
            const operationType = report.method === 'commit-reveal' ? 'REGISTRATION (Commit-Reveal)' : 'REGISTRATION';
            const status = '✅ SUCCESSFULLY REGISTERED';
            
            let text = `${status}\n`;
            text += `Operation type: ${operationType}\n`;
            text += `Owner: ${report.owner || report.userAddress}\n`;
            text += `Owner address: ${report.owner || report.userAddress}\n`;
            text += `Registration date: ${report.registrationDate}\n`;
            text += `Content hash: ${report.contentHash}\n`;
            text += `Transaction: ${report.transactionHash}\n`;
            text += `Block: ${report.blockNumber}\n`;
            
            if (report.commitBlock) text += `Commit block: ${report.commitBlock}\n`;
            if (report.revealBlock) text += `Reveal block: ${report.revealBlock}\n`;
            if (report.salt) text += `Salt: ${report.salt}\n`;
            
            text += `Network: ${report.network}\n`;
            text += `\nDigital Notary DApp - ${new Date().toLocaleDateString('ru-RU')}`;
            
            return text;
        }

        function formatVerificationReport(report) {
            const status = report.exists ? '✅ SUCCESSFULLY VERIFIED' : '❌ NOT REGISTERED';
            
            let text = `${status}\n`;
            text += `Operation type: REGISTRATION VERIFICATION\n`;
            text += `Content hash: ${report.contentHash}\n`;
            
            if (report.exists) {
                text += `Owner: ${report.registrant}\n`;
                text += `Owner address: ${report.registrant}\n`;
                text += `Original registrant: ${report.originalRegistrant}\n`; 
                text += `Registration date: ${formatDate(new Date(report.timestamp * 1000))}\n`;
                text += `Rights transfer count: ${report.transferCount}\n`;
                text += `Last transfer: ${report.lastTransferTime > 0 ? formatDate(new Date(report.lastTransferTime * 1000)) : 'Not transferred'}\n`;
            } else {
                text += `Status: Content not registered in system\n`;
            }
            
            if (report.transactionHash) {
                text += `Verification transaction: ${report.transactionHash}\n`;
                text += `Verification block: ${report.blockNumber}\n`;
            }
            
            text += `Network: ${report.network}\n`;
            text += `\nDigital Notary DApp - ${new Date().toLocaleDateString('ru-RU')}`;
            
            return text;
        }

        function formatTransferReport(report) {
    const status = '✅ RIGHTS SUCCESSFULLY TRANSFERRED';
    
    let text = `${status}\n`;
    text += `Operation type: RIGHTS TRANSFER\n`;
    text += `Content hash: ${report.contentHash}\n`;
    text += `Previous owner: ${report.previousOwner}\n`;
    text += `New owner: ${report.newOwner}\n`;
    text += `Transfer date: ${report.transferDate}\n`; // УЖЕ ОТФОРМАТИРОВАНА
    text += `First registration date: ${report.originalRegistrationDate || 'Unknown'}\n`;
    text += `Original registrant: ${report.originalRegistrant || 'Unknown'}\n`;
    text += `Transaction: ${report.transactionHash}\n`;
    text += `Block: ${report.blockNumber}\n`;
    text += `Network: ${report.network}\n`;
    text += `\nDigital Notary DApp - ${formatDate(new Date())}`;
    
    return text;
}
        function formatContractTransferReport(report) {
            const status = '🚨 CONTRACT OWNERSHIP TRANSFERRED';
            
            let text = `${status}\n`;
            text += `Operation type: CONTRACT OWNERSHIP TRANSFER\n`;
            text += `Previous owner: ${report.previousOwner}\n`;
            text += `New owner: ${report.newOwner}\n`;
            text += `Transaction: ${report.transactionHash}\n`;
            text += `Block: ${report.blockNumber}\n`;
            text += `Network: ${report.network}\n`;
            text += `\nWARNING: This operation is irreversible. Previous owner lost all management rights.\n`;
            text += `\nDigital Notary DApp - ${new Date().toLocaleDateString('ru-RU')}`;
            
            return text;
        }

        function formatDate(date) {
    if (!date || isNaN(date.getTime())) return 'Неизвестно';
    
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    
    return `${day}.${month}.${year}, ${hours}:${minutes}:${seconds}`;
}
   

        function generateReportFileName(report) {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const hashShort = report.contentHash ? report.contentHash.substring(0, 16) : 'unknown';
            
            switch(report.type) {
                case 'registration': return `registration_${hashShort}_${timestamp}.txt`;
                case 'verification': return `verification_${hashShort}_${timestamp}.txt`;
                case 'transfer': return `rights_transfer_${hashShort}_${timestamp}.txt`;
                case 'contract_transfer': return `contract_transfer_${timestamp}.txt`;
                default: return `report_${timestamp}.txt`;
            }
        }

        async function copyReportToClipboard() {
            if (!currentReport) {
                showNotification("Report not yet generated.", "error");
                return;
            }
            
            const textToCopy = formatReportAsText(currentReport);
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showNotification("Report copied to clipboard!", "success");
            } catch (err) {
                const textArea = document.createElement("textarea");
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand("copy");
                document.body.removeChild(textArea);
                showNotification("Report copied to clipboard!", "success");
            }
        }

        function downloadReport() {
            if (!currentReport) {
                showNotification("Report not yet generated.", "error");
                return;
            }

            const text = formatReportAsText(currentReport);
            const blob = new Blob([text], { type: "text/plain; charset=utf-8" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement("a");
            link.href = url;
            const fileName = generateReportFileName(currentReport);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            showNotification("Report downloaded successfully!", "success");
        }

        function createReport(type, data, receipt) {
            const timestamp = new Date().toISOString();
            
            currentReport = {
                type: type,
                timestamp: timestamp,
                network: currentNetwork ? currentNetwork.name : 'Unknown',
                userAddress: currentUserAddress,
                ...data
            };
            
            if (receipt) {
                currentReport.transactionHash = receipt.transactionHash;
                currentReport.blockNumber = receipt.blockNumber;
            }
            
            console.log("Report generated:", currentReport);
            return currentReport;
        }

        function updateReportUI(resultElementId, reportData) {
            const resultElement = document.getElementById(resultElementId);
            if (!resultElement) return;
            
            const reportReadyHtml = `
                <div class="report-ready-indicator">
                    ✅ Report ready for copying or downloading
                </div>
                <div class="operation-controls">
                    <button class="btn btn-success" onclick="copyReportToClipboard()">📋 Copy report</button>
                    <button class="btn btn-info" onclick="downloadReport()">💾 Download report</button>
                </div>
            `;
            
            const existingContent = resultElement.innerHTML;
            resultElement.innerHTML = existingContent + reportReadyHtml;
        }

        // ==================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ====================

        // ==================== ОБРАБОТЧИКИ СОБЫТИЙ META MASK ====================

        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('chainChanged', (chainId) => {
                console.log('Network changed:', chainId);
                showNotification('Network change detected...', 'info');
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            });

            window.ethereum.on('accountsChanged', (accounts) => {
                console.log('Accounts changed:', accounts);
                if (accounts.length === 0) {
                    document.getElementById('walletInfo').style.display = 'none';
                    document.getElementById('ownerNavItem').classList.add('owner-only');
                    document.getElementById('ownerNavItem').style.display = 'none';
                    document.getElementById('ownerTab').classList.add('owner-section');
                    showNotification('MetaMask disconnected', 'warning');
                } else {
                    showNotification('Account change detected...', 'info');
                    setTimeout(() => connectMetaMask(), 1000);
                }
            });

            window.ethereum.on('connect', (connectInfo) => {
                console.log('MetaMask connected:', connectInfo);
                connectMetaMask();
            });

            window.ethereum.on('disconnect', (error) => {
                console.log('MetaMask disconnected:', error);
                document.getElementById('walletInfo').style.display = 'none';
                showNotification('MetaMask disconnected', 'warning');
            });
        }

        // Добавляем обработчик загрузки страницы
        window.addEventListener('load', function() {
            setTimeout(() => {
                initializeApp();
            }, 100); // Небольшая задержка для полной загрузки DOM
        });
        // === ДОБАВИТЬ НОВУЮ ФУНКЦИЮ В КОНЕЦ ===
function closeAllNotifications() {
    const notifications = document.querySelectorAll('.notification');
    notifications.forEach(notification => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    });
}
       // ГЛОБАЛЬНАЯ ФУНКЦИЯ ДЛЯ ДЕБАГГИНГА
window.debugApp = function() {
    console.log('=== APP DEBUG INFO ===');
    console.log('Provider:', provider);
    console.log('Signer:', signer);
    console.log('Contract:', contract);
    console.log('Current Network:', currentNetwork);
    console.log('Current User:', currentUserAddress);
    console.log('Is Owner:', isOwner);
    console.log('User Agreed:', userAgreed);
    console.log('Contract State:', document.getElementById('contractStatus').textContent);
    
    // Проверка элементов управления
    console.log('Verify Button disabled:', document.getElementById('verifyContent').disabled);
    console.log('Transfer Button disabled:', document.getElementById('transferOwnership').disabled);
    console.log('Verify Hash value:', document.getElementById('verifyHash').value);
    console.log('Transfer Hash value:', document.getElementById('transferHash').value);
    console.log('New Owner Address value:', document.getElementById('newOwnerAddress').value);
    console.log('========================');
};

// АВТОМАТИЧЕСКАЯ ПЕРЕИНИЦИАЛИЗАЦИЯ ПРИ ПОДКЛЮЧЕНИИ METAMASK
if (typeof window.ethereum !== 'undefined') {
    window.ethereum.on('connect', (connectInfo) => {
        console.log('MetaMask connected - reinitializing contract');
        setTimeout(() => {
            initializeContract().then(() => {
                console.log('Contract reinitialized after MetaMask connection');
            });
        }, 1000);
    });
}

// ДОПОЛНИТЕЛЬНАЯ ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ
document.addEventListener('DOMContentLoaded', function() {
    console.log('DApp fully loaded - final initialization');
    
    // ПЕРЕИНИЦИАЛИЗАЦИЯ ЧЕРЕЗ 2 СЕКУНДЫ ДЛЯ УСТОЙЧИВОСТИ
    setTimeout(() => {
        if (contract) {
            console.log('Final contract reinitialization');
            initializeContract().then(() => {
                console.log('Final initialization complete');
                
                // ПРОВЕРКА ДОСТУПНОСТИ ФУНКЦИЙ
                if (document.getElementById('verifyContent')) {
                    console.log('Verify button element found');
                }
                if (document.getElementById('transferOwnership')) {
                    console.log('Transfer button element found');
                }
            });
        }
    }, 2000);
});

    </script>
</body>
</html>